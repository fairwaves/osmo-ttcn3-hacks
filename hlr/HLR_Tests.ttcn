module HLR_Tests {

import from GSUP_Types all;
import from GSUP_Emulation all;
import from IPA_Emulation all;

import from General_Types all;
import from Osmocom_Types all;
import from Osmocom_CTRL_Adapter all;

import from TCCEncoding_Functions all;
import from SS_Types all;
import from SS_Templates all;
import from MAP_Errors all;
import from USSD_Helpers all;

import from Osmocom_VTY_Functions all;
import from TELNETasp_PortType all;

type component test_CT extends CTRL_Adapter_CT {
	var IPA_Emulation_CT vc_IPA;
	var IPA_CCM_Parameters ccm_pars;
	/* legacy tests without ConnHdlr */
	port IPA_GSUP_PT GSUP;
	/* new tests using ConnHdlr + GSUP_Emulation */
	var GSUP_Emulation_CT vc_GSUP;
	/* only to get events from IPA underneath GSUP */
	port IPA_CTRL_PT GSUP_IPA_EVENT;

	port TELNETasp_PT VTY;

	timer g_Tguard := 10.0;
};

modulepar {
	charstring mp_hlr_ip := "127.0.0.1";
	integer mp_hlr_gsup_port := 4222;
	integer mp_hlr_ctrl_port := 4259;
};

type record HlrSubscrAud2G {
	charstring algo,
	OCT16 ki
}

type record HlrSubscrAud3G {
	charstring algo,
	OCT16 k,
	OCT16 op,
	boolean op_is_opc
}

type record HlrSubscriber {
	hexstring imsi,
	hexstring msisdn,
	HlrSubscrAud2G aud2g optional,
	HlrSubscrAud3G aud3g optional
}

type record of HlrSubscriber HlrSubscriberList;

type component HLR_ConnHdlr extends GSUP_ConnHdlr {
	timer g_Tguard := 10.0;
	var HLR_ConnHdlrPars g_pars;
	port TELNETasp_PT VTY;
}

type record HLR_ConnHdlrPars {
	HlrSubscriber sub,
	HLR_ConnHdlrParsUssd ussd optional
}

type record HLR_ConnHdlrParsUssd {
	OCT4 sid
}

template (value) HLR_ConnHdlrPars t_Pars(hexstring imsi, hexstring msisdn := ''H) := {
	sub := {
		imsi := imsi,
		msisdn := msisdn,
		aud2g := omit,
		aud3g := omit
	},
	ussd := omit
}

type function void_fn() runs on HLR_ConnHdlr;

/***********************************************************************
 * Main Component
 ***********************************************************************/

function f_init_vty() runs on test_CT {
	map(self:VTY, system:VTY);
	f_vty_set_prompts(VTY);
	f_vty_transceive(VTY, "enable");
}

private altstep as_Tguard() runs on test_CT {
	[] g_Tguard.timeout {
		setverdict(fail, "g_Tguard timeout");
		mtc.stop;
	}
}

function f_init_gsup(charstring id, boolean legacy) runs on test_CT {
	id := id & "-GSUP";
	var GsupOps ops := {
		create_cb := refers(GSUP_Emulation.ExpectedCreateCallback)
	}

	ccm_pars := c_IPA_default_ccm_pars;
	ccm_pars.name := "Osmocom TTCN-3 GSUP Simulator";
	ccm_pars.ser_nr := "MSC-00-00-00-00-00-00";

	vc_IPA := IPA_Emulation_CT.create(id & "-IPA");
	vc_GSUP := GSUP_Emulation_CT.create(id);

	map(vc_IPA:IPA_PORT, system:IPA_CODEC_PT);
	connect(vc_GSUP:GSUP, vc_IPA:IPA_GSUP_PORT);
	connect(vc_IPA:IPA_CTRL_PORT, self:GSUP_IPA_EVENT);
	vc_GSUP.start(GSUP_Emulation.main(ops, id));
	vc_IPA.start(IPA_Emulation.main_client(mp_hlr_ip, mp_hlr_gsup_port, "", -1, ccm_pars));

  log("vc_IPA: ", vc_IPA);
  GSUP_IPA_EVENT.receive(t_ASP_IPA_EVT_UD(ASP_IPA_EVENT_UP));
	/* wait for incoming connection to GSUP port before proceeding
	timer T := 10.0;
	T.start;
	alt {
		[not legacy] GSUP_IPA_EVENT.receive(t_ASP_IPA_EVT_UD(ASP_IPA_EVENT_UP)) { }
		[] T.timeout {
			setverdict(fail, "No connection to GSUP Port");
			GSUP_IPA_EVENT.receive(t_ASP_IPA_EVT_UD(ASP_IPA_EVENT_UP));
		}
	}*/
}

function f_init(boolean legacy := true) runs on test_CT {
	f_init_gsup("HLR_Test", legacy);
}

function f_start_handler(void_fn fn, HLR_ConnHdlrPars pars) runs on test_CT return HLR_ConnHdlr {
	var HLR_ConnHdlr vc_conn;
	var charstring id := testcasename();

	vc_conn := HLR_ConnHdlr.create(id);
	connect(vc_conn:GSUP, vc_GSUP:GSUP_CLIENT);
	connect(vc_conn:GSUP_PROC, vc_GSUP:GSUP_PROC);

	vc_conn.start(f_handler_init(fn, id, pars));
	return vc_conn;
}

private function f_handler_init_vty() runs on HLR_ConnHdlr {
	map(self:VTY, system:VTY);
	f_vty_set_prompts(VTY);
	f_vty_transceive(VTY, "enable");
}

/* first function inside ConnHdlr component; sets g_pars + starts function */
function f_handler_init(void_fn fn, charstring id, template (omit) HLR_ConnHdlrPars pars := omit)
runs on HLR_ConnHdlr
{
	if (isvalue(pars)) {
		g_pars := valueof(pars);
		f_create_gsup_expect(hex2str(g_pars.sub.imsi));
	}
	f_handler_init_vty();
	fn.apply();
}

/***********************************************************************
 * Helper functions for ConnHdlr
 ***********************************************************************/

/* perform SendAuthInfo for given imsi, return the GSUP response/error */
function f_perform_SAI(hexstring imsi, template (omit) integer exp_err_cause := omit)
runs on HLR_ConnHdlr return GSUP_PDU {
	var GSUP_PDU ret;
	timer T := 3.0;
	var boolean exp_fail := false;
	if (not istemplatekind(exp_err_cause, "omit")) {
		exp_fail := true;
	}

	GSUP.send(valueof(ts_GSUP_SAI_REQ(imsi)));
	T.start;
	alt {
	[exp_fail] GSUP.receive(tr_GSUP_SAI_ERR(imsi, exp_err_cause)) -> value ret {
		setverdict(pass);
		}
	[exp_fail] GSUP.receive(tr_GSUP_SAI_ERR(imsi, ?)) -> value ret {
		setverdict(fail, "Unexpected SAI ERROR Cause");
		}
	[exp_fail] GSUP.receive(tr_GSUP_SAI_RES(imsi)) -> value ret {
		setverdict(fail, "Unexpected SAI.res for unknown IMSI");
		}
	[not exp_fail] GSUP.receive(tr_GSUP_SAI_ERR(imsi, ?)) -> value ret {
		setverdict(fail, "Unexpected SAI ERROR");
		}
	[not exp_fail] GSUP.receive(tr_GSUP_SAI_RES(imsi)) -> value ret {
		setverdict(pass);
		}
	[] GSUP.receive { repeat; }
	[] T.timeout {
		setverdict(fail, "Timeout waiting for SAI response");
		mtc.stop;
		}
	}
	return ret;
}

/***********************************************************************
 * Testcases
 ***********************************************************************/

/* 23.003 Section 2.2 clearly states that an IMSI with less
 * than 5 digits is impossible. Even 5 digits is still questionable */
private function f_TC_gsup_sai_err_invalid_imsi() runs on HLR_ConnHdlr {
	var GSUP_PDU res;
	log("res: ", res);
	res := f_perform_SAI(g_pars.sub.imsi, 96); /* Invalid Mandatory information */
	setverdict(pass);
}
testcase TC_gsup_sai_err_invalid_imsi() runs on test_CT {
	var HLR_ConnHdlr vc_conn;
	var HLR_ConnHdlrPars pars := valueof(t_Pars('0123'H));
	log("pars: ", pars);
	f_init(false);
	vc_conn := f_start_handler(refers(f_TC_gsup_sai_err_invalid_imsi), pars);
	vc_conn.done;
}

control {
	execute( TC_gsup_sai_err_invalid_imsi() );
};

};
