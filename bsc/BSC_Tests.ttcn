module BSC_Tests {

import from Osmocom_Types all;
import from GSM_Types all;
import from IPL4asp_Types all;

import from BSSAP_Adapter all;
import from BSSAP_CodecPort all;
import from BSSMAP_Templates all;
import from IPA_Emulation all;
import from IPA_Types all;
import from RSL_Types all;

import from Osmocom_CTRL_Functions all;

import from RSL_Tests all;

const integer NUM_BTS := 1;
const float T3101_MAX := 12.0;

type record BTS_State {
	IPA_Client rsl,
	IPA_Client ctrl
}

type component test_CT extends BSSAP_Adapter_CT {
	var BTS_State bts[NUM_BTS];
	port IPA_RSL_PT IPA_RSL[NUM_BTS];
	port IPA_CTRL_PT IPA_CTRL[NUM_BTS];

	var boolean g_initialized := false;
	timer T_guard := 30.0;

}

modulepar {
	charstring mp_bsc_ip := "127.0.0.1";
	integer mp_bsc_rsl_port := 3003;
	integer mp_bsc_ctrl_port := 4249;
}

type record IPA_Client {
	IPA_Emulation_CT vc_IPA,
	IPA_CCM_Parameters ccm_pars,
	charstring id
}

function f_ipa_rsl_start(inout IPA_Client clnt, charstring bsc_host, PortNumber bsc_port, integer i)
runs on test_CT {
	timer T := 10.0;

	clnt.id := "IPA" & int2str(i) & "-RSL";
	clnt.vc_IPA := IPA_Emulation_CT.create(clnt.id & "-IPA");
	clnt.ccm_pars := c_IPA_default_ccm_pars;
	clnt.ccm_pars.name := "Osmocom TTCN-3 BTS Simulator";
	clnt.ccm_pars.unit_id := int2str(1234+i) & "/0/0";

	map(clnt.vc_IPA:IPA_PORT, system:IPA_CODEC_PT);
	connect(clnt.vc_IPA:IPA_RSL_PORT, self:IPA_RSL[i]);

	clnt.vc_IPA.start(IPA_Emulation.main_client(bsc_host, bsc_port, "", -1, clnt.ccm_pars));

	/* wait for IPA RSL link to connect and send ID ACK */
	T.start;
	alt {
	[] IPA_RSL[i].receive(ASP_IPA_Event:{up_down := ASP_IPA_EVENT_ID_ACK}) {
		T.stop;
		IPA_RSL[i].send(ts_ASP_RSL_UD(IPAC_PROTO_RSL_TRX0,ts_RSL_PAGING_LOAD_IND(23)));
		}
	[] IPA_RSL[i].receive { repeat }
	[] T.timeout {
		setverdict(fail, "Timeout RSL waiting for ASP_IPA_EVENT_ID_ACK");
		self.stop;
		}
	}
}

function f_ipa_ctrl_start(inout IPA_Client clnt, charstring bsc_host, PortNumber bsc_port, integer i)
runs on test_CT {
	timer T := 10.0;

	clnt.id := "IPA" & int2str(i) & "-CTRL";
	clnt.vc_IPA := IPA_Emulation_CT.create(clnt.id & "-IPA");

	map(clnt.vc_IPA:IPA_PORT, system:IPA_CODEC_PT);
	connect(clnt.vc_IPA:IPA_CTRL_PORT, self:IPA_CTRL[i]);

	clnt.vc_IPA.start(IPA_Emulation.main_client(bsc_host, bsc_port, "", -1));

	/* wait for IPA CTRL link to connect and send UP */
	T.start;
	alt {
	[] IPA_CTRL[i].receive(ASP_IPA_Event:{up_down := ASP_IPA_EVENT_UP}) { }
	[] T.timeout {
		setverdict(fail, "Timeout CTRL waiting for ASP_IPA_EVENT_UP");
		self.stop;
		}
	}
}


function f_sleep(float seconds) {
	timer T := seconds;
	T.start;
	T.timeout;
}

altstep as_Tguard() runs on test_CT {
	[] T_guard.timeout { setverdict(fail, "Timeout of T_guard"); }
}

function f_init() runs on test_CT {
	var integer i;

	if (g_initialized) {
		return;
	}
	g_initialized := true;

	/* Call a function of our 'parent component' BSSAP_Adapter_CT to start the
	 * MSC-side BSSAP emulation */
	f_bssap_init("VirtMSC");

	f_sleep(5.0);

	for (i := 0; i < NUM_BTS; i := i+1) {
		f_ipa_rsl_start(bts[i].rsl, mp_bsc_ip, mp_bsc_rsl_port, i);
		f_ipa_ctrl_start(bts[i].ctrl, mp_bsc_ip, mp_bsc_ctrl_port, i);
	}
	f_sleep(0.5);

	T_guard.start;
	activate(as_Tguard());
}

function f_exp_ipa_rx(integer bts_nr, template RSL_Message t_rx, float t_secs := 2.0, IpaStreamId sid := IPAC_PROTO_RSL_TRX0)
runs on test_CT return RSL_Message {
	var ASP_RSL_Unitdata rx_rsl_ud;
	timer T := t_secs;

	T.start;
	alt {
	[] IPA_RSL[bts_nr].receive(tr_ASP_RSL_UD(sid, t_rx)) -> value rx_rsl_ud {
		T.stop;
		}
	[] IPA_RSL[bts_nr].receive { repeat; }
	[] T.timeout { setverdict(fail, "Timeout expecting ", t_rx); }
	}
	return rx_rsl_ud.rsl;
}

function f_ipa_tx(integer bts_nr, template RSL_Message t_tx, IpaStreamId sid := IPAC_PROTO_RSL_TRX0)
runs on test_CT {
	IPA_RSL[bts_nr].send(ts_ASP_RSL_UD(sid, t_tx));
}


testcase TC_chan_act_noreply() runs on test_CT {
	var BSSAP_N_UNITDATA_ind ud_ind;

	f_init();
	f_bssap_reset();

	IPA_RSL[0].send(ts_ASP_RSL_UD(IPAC_PROTO_RSL_TRX0,ts_RSL_CHAN_RQD('23'O, 23)));
	f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_CHAN_ACTIV));
	setverdict(pass);
}

/* CHAN RQD -> CHAN ACT -> CHAN ACT ACK -> RF CHAN REL */
testcase TC_chan_act_ack_noest() runs on test_CT {
	var RSL_Message rx_rsl;

	f_init();
	f_bssap_reset();

	/* Send CHAN RQD and wait for allocation; acknowledge it */
	f_ipa_tx(0, ts_RSL_CHAN_RQD('23'O, 23));
	rx_rsl := f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_CHAN_ACTIV));
	var RslChannelNr chan_nr := rx_rsl.ies[0].body.chan_nr;
	f_ipa_tx(0, ts_RSL_CHAN_ACT_ACK(chan_nr, 23));

	/* expect BSC to disable the channel again if there's no RLL EST IND */
	rx_rsl := f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_RF_CHAN_REL), T3101_MAX);

	setverdict(pass);
}

/* Test behavior if MSC never answers to CR */
testcase TC_chan_act_ack_est_ind_noreply() runs on test_CT {
	var RSL_Message rx_rsl;

	f_init();
	f_bssap_reset();

	/* Send CHAN RQD and wait for allocation; acknowledge it */
	f_ipa_tx(0, ts_RSL_CHAN_RQD('23'O, 23));
	rx_rsl := f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_CHAN_ACTIV));
	var RslChannelNr chan_nr := rx_rsl.ies[0].body.chan_nr;
	f_ipa_tx(0, ts_RSL_CHAN_ACT_ACK(chan_nr, 23));

	var octetstring l3 := '00010203040506'O
	f_ipa_tx(0, ts_RSL_EST_IND(chan_nr, valueof(ts_RslLinkID_DCCH(0)), l3));

	BSSAP.receive(tr_BSSAP_CONNECT_ind(?, ?, tr_BSSMAP_ComplL3(l3)));

	/* expect BSC to disable the channel again if there's no response from MSC */
	rx_rsl := f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_RF_CHAN_REL), T3101_MAX);

	setverdict(pass);
}

/* Test behavior if MSC answers with CREF to CR */
testcase TC_chan_act_ack_est_ind_refused() runs on test_CT {
	var BSSAP_N_CONNECT_ind rx_c_ind;
	var RSL_Message rx_rsl;

	f_init();
	f_bssap_reset();

	/* Send CHAN RQD and wait for allocation; acknowledge it */
	f_ipa_tx(0, ts_RSL_CHAN_RQD('23'O, 23));
	rx_rsl := f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_CHAN_ACTIV));
	var RslChannelNr chan_nr := rx_rsl.ies[0].body.chan_nr;
	f_ipa_tx(0, ts_RSL_CHAN_ACT_ACK(chan_nr, 23));

	var octetstring l3 := '00010203040506'O
	f_ipa_tx(0, ts_RSL_EST_IND(chan_nr, valueof(ts_RslLinkID_DCCH(0)), l3));

	BSSAP.receive(tr_BSSAP_CONNECT_ind(?, ?, tr_BSSMAP_ComplL3(l3))) -> value rx_c_ind;
	BSSAP.send(ts_BSSAP_DISC_req(rx_c_ind.connectionId, 0));

	/* expect BSC to disable the channel */
	rx_rsl := f_exp_ipa_rx(0, tr_RSL_MsgTypeD(RSL_MT_RF_CHAN_REL), T3101_MAX);

	setverdict(pass);
}

testcase TC_ctrl() runs on test_CT {

	f_init();
	f_bssap_reset();

	f_ctrl_get(IPA_CTRL[0], "bts.0.location-area-code");
}



control {
	execute( TC_ctrl() );
	execute( TC_chan_act_noreply() );
	execute( TC_chan_act_ack_noest() );
	execute( TC_chan_act_ack_est_ind_noreply() );
	execute( TC_chan_act_ack_est_ind_refused() );
}

}
