module GGSN_Tests {

	import from General_Types all;
	import from Osmocom_Types all;
	import from IPL4asp_PortType all;
	import from IPL4asp_Types all;
	import from GTP_CodecPort all;
	import from GTP_CodecPort_CtrlFunct all;
	import from GTPC_Types all;
	import from GTPU_Types all;
	import from IPCP_Types all;
	import from IP_Types all;
	import from ICMPv6_Types all;
	import from Native_Functions all;

	const integer GTP0_PORT := 3386;
	const integer GTP1C_PORT := 2123;
	const integer GTP1U_PORT := 2152;

	modulepar {
		charstring m_bind_ip_gtpc := "127.23.42.1";
		charstring m_bind_ip_gtpu := "127.23.42.1";

		charstring m_ggsn_ip_gtpc := "127.0.0.6";
		charstring m_ggsn_ip_gtpu := "127.0.0.6";

		charstring m_ggsn_ip4_dns1 := "192.168.100.1"
		charstring m_ggsn_ip4_dns2 := "8.8.8.8"
		charstring m_ggsn_ip6_dns1 := "2001:4860:4860::8888"
		charstring m_ggsn_ip6_dns2 := "2001:4860:4860::8844"
	}

	type set PdpContext {
		hexstring	imsi,
		octetstring	msisdn optional,
		octetstring	apn,
		ProtConfigOptions	pco_req optional,
		ProtConfigOptions	pco_neg optional,
		EndUserAddress	eua,
		OCT16		ip6_prefix optional,
		BIT4		nsapi,
		/* TEI (Data) local side */
		OCT4		teid,
		/* TEI (Control) local side */
		OCT4		teic,
		/* TEI (Data) remote side */
		OCT4		teid_remote,
		/* TEI (Control) remote side */
		OCT4		teic_remote
	}

	type component GT_CT {
		port GTPC_PT GTPC;
		port GTPU_PT GTPU;

		var boolean g_initialized := false;

		var OCT1 g_restart_ctr := '01'O;
		/* FIXME: unify with g_bind_ip + parse from config file */
		var OCT4 g_sgsn_ip_c;
		var OCT4 g_sgsn_ip_u;
		/* FIXME: parse remName from config file */
		var GtpPeer g_peer_c := { connId := 0, remName := m_ggsn_ip_gtpc, remPort := GTP1C_PORT };
		var GtpPeer g_peer_u := { connId := 0, remName := m_ggsn_ip_gtpu, remPort := GTP1U_PORT };
		timer T_default := 3.0;

		/* next to-be-sent GTP-C sequence number */
		var uint16_t g_c_seq_nr;
		/* next to-be-sent GTP-U sequence number */
		var uint16_t g_d_seq_nr;
	}

	function f_init() runs on GT_CT {
		if (g_initialized == true) {
			return;
		}
		g_initialized := true;

		g_sgsn_ip_c := f_inet_addr(m_bind_ip_gtpc);
		g_sgsn_ip_u := f_inet_addr(m_bind_ip_gtpu);

		var Result res;
		map(self:GTPC, system:GTPC);
		res := GTP_CodecPort_CtrlFunct.f_IPL4_listen(GTPC, m_bind_ip_gtpc, GTP1C_PORT, {udp:={}});
		log("GTP1C ConnectionID: ", res.connId);
		g_peer_c.connId := res.connId;

		map(self:GTPU, system:GTPU);
		res := GTP_CodecPort_CtrlFunct.f_GTPU_listen(GTPU, m_bind_ip_gtpu, GTP1U_PORT, {udp:={}});
		g_peer_u.connId:= res.connId;

		g_restart_ctr := f_rnd_octstring(1);
		g_c_seq_nr := f_rnd_int(65535);
		g_d_seq_nr := f_rnd_int(65535);
	}

	/* generalized GTP-C receive template */
	template PDU_GTPC tr_GTP1C_PDU(template OCT1 msg_type, template OCT4 teid, template GTPC_PDUs pdu := ?) := {
		/* N-PDU Number flag (PN) shall be set to '0'. A GTP-C receiver shall not return an
		 * error if this flag is set to '1'. */
		pn_bit := '0'B,
		/* Sequence number flag (S) shall be set to '1'. */
		s_bit := '1'B,
		e_bit := ?,
		spare := ?,
		/* Protocol Type flag (PT) shall be set to '1'.*/
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := ?,
		teid := teid,
		opt_part := *,
		gtpc_pdu := pdu
	}

	/* generalized GTP-C send template */
	template PDU_GTPC ts_GTP1C_PDU(OCT1 msg_type, OCT4 teid, GTPC_PDUs pdu, uint16_t seq_nr) := {
		/* N-PDU Number flag (PN) shall be set to '0'. A GTP-C receiver shall not return an
		 * error if this flag is set to '1'. */
		pn_bit := '0'B,
		/* Sequence number flag (S) shall be set to '1'. */
		s_bit := '1'B,
		e_bit := '0'B,
		spare := '0'B,
		/* Protocol Type flag (PT) shall be set to '1'.*/
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := 0,	/* we assume encoder overwrites this */
		teid := teid,
		opt_part := {
			sequenceNumber := int2oct(seq_nr, 2),
			npduNumber := '00'O,
			nextExtHeader := '00'O,
			gTPC_extensionHeader_List := omit
		},
		gtpc_pdu := pdu
	}

	/* recovery IE */
	template Recovery_gtpc ts_Recovery(OCT1 restart_counter) := {
		type_gtpc := '0E'O,
		restartCounter := restart_counter
	}

	template Recovery_gtpc tr_Recovery(template OCT1 restart_counter) := {
		type_gtpc := '0E'O,
		restartCounter := restart_counter
	}

	/* template matching reception of GTP-C echo-request */
	template Gtp1cUnitdata tr_GTPC_MsgType(template GtpPeer peer, template OCT1 msg_type, template OCT4 teid, template GTPC_PDUs pdus := ?) := {
		peer := peer,
		gtpc := tr_GTP1C_PDU(msg_type, teid, pdus)
	}

	/* template matching reception of GTP-C echo-request */
	template Gtp1cUnitdata tr_GTPC_PING(template GtpPeer peer) := tr_GTPC_MsgType(peer, echoRequest, '00000000'O);

	template GTPC_PDUs tr_EchoRespPDU(template OCT1 restart_counter) := {
		echoResponse := {
			recovery := tr_Recovery(restart_counter),
			private_extension_gtpc := *
		}
	}

	/* template matching reception of GTP-C echo-response */
	template Gtp1cUnitdata tr_GTPC_PONG(template GtpPeer peer) := tr_GTPC_MsgType(peer, echoResponse, '00000000'O, tr_EchoRespPDU(?));

	template GTPC_PDUs ts_EchoRespPDU(OCT1 restart_counter) := {
		echoResponse := {
			recovery := ts_Recovery(restart_counter),
			private_extension_gtpc := omit
		}
	}

	/* master template for senidng a GTP-C echo response */
	template Gtp1cUnitdata ts_GTPC_PONG(GtpPeer peer, uint16_t seq, OCT1 rest_ctr) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(echoResponse, '00000000'O, valueof(ts_EchoRespPDU(rest_ctr)), seq)
	}

	template GTPC_PDUs ts_EchoReqPDU := {
		echoRequest := {
			private_extension_gtpc := omit
		}
	}

	/* master template for sending a GTP-C echo request */
	template Gtp1cUnitdata ts_GTPC_PING(GtpPeer peer, uint16_t seq) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(echoRequest, '00000000'O, valueof(ts_EchoReqPDU), seq)
	}

	template EndUserAddress t_EuaIPv4(template OCT4 ip_addr) := {
		type_gtpc := '80'O,
		endUserAddress := {
			endUserAddressIPv4 := {
				lengthf := 2,
				pdp_typeorg := '0001'B,
				spare := '1111'B,
				pdp_typenum := '21'O,
				ipv4_address := ip_addr
			}
		}
	}
	template EndUserAddress t_EuaIPv4Dyn := t_EuaIPv4(omit);
	template EndUserAddress tr_EuaIPv4(template OCT4 ip_addr) modifies t_EuaIPv4 := {
		endUserAddress := {
			endUserAddressIPv4 := {
				lengthf := 2+lengthof(ip_addr)
			}
		}
	}

	template EndUserAddress t_EuaIPv6(template OCT16 ip_addr) := {
		type_gtpc := '80'O,
		endUserAddress := {
			endUserAddressIPv6 := {
				lengthf := 2,
				pdp_typeorg := '0001'B,
				spare := '1111'B,
				pdp_typenum := '57'O,
				ipv6_address := ip_addr
			}
		}
	}
	template EndUserAddress t_EuaIPv6Dyn := t_EuaIPv6(omit);
	template EndUserAddress tr_EuaIPv6(template OCT16 ip_addr) modifies t_EuaIPv6 := {
		endUserAddress := {
			endUserAddressIPv6 := {
				lengthf := 2+lengthof(ip_addr)
			}
		}
	}

	template AccessPointName ts_APN(octetstring apn) := {
		type_gtpc := '83'O,
		lengthf := lengthof(apn),
		apn_value := apn
	}

	template GSN_Address_GTPC ts_GsnAddr(octetstring ip_addr) := {
		type_gtpc := '85'O,
		lengthf := lengthof(ip_addr),
		addressf := ip_addr
	}

	template MSISDN ts_Msisdn(octetstring msisdn) := {
		type_gtpc := '86'O,
		lengthf := lengthof(msisdn),
		msisdn := msisdn
	}

	template QualityOfServiceProfile ts_QosDefault := {
		type_gtpc := '87'O,
		lengthf := 4,
		allocRetensionPrio := '00'O,
		qos_ProfileValue := {
			reliabilityClass := '011'B,
			delayClass := '001'B,
			spare1 := '00'B,
			precedenceClass := '010'B,
			spare2 := '0'B,
			peakThroughput := '1001'B,
			meanThroughput := '11111'B,
			spare3 := '000'B,
			deliverErroneusSDU := omit,
			deliveryOrder := omit,
			trafficClass := omit,
			maxSDUSize := omit,
			maxBitrateUplink := omit,
			maxBitrateDownlink := omit,
			sduErrorRatio := omit,
			residualBER := omit,
			trafficHandlingPriority := omit,
			transferDelay := omit,
			guaranteedBitRateUplink := omit,
			guaranteedBitRateDownlink := omit,
			sourceStatisticsDescriptor := omit,
			signallingIndication := omit,
			spare4 := omit,
			maxBitrateDownlinkExt := omit,
			guaranteedBitRateDownlinkExt := omit,
			maxBitrateUplinkExt := omit,
			guaranteedBitRateUplinkExt := omit
		}
	}

	template IMSI_gtpc ts_Imsi(hexstring digits) := {
		type_gtpc := '02'O,
		digits := digits,
		padding := 'F'H
	}

	template GTPC_PDUs ts_CreatePdpPDU(hexstring imsi, OCT1 restart_ctr, OCT4 teid_data, OCT4 teid_ctrl,
					   BIT4 nsapi, EndUserAddress eua, octetstring apn,
					   octetstring sgsn_ip_sign, octetstring sgsn_ip_data,
					   octetstring msisdn, template ProtConfigOptions pco := omit) := {
		createPDPContextRequest := {
			imsi := ts_Imsi(imsi),
			rai := omit,
			recovery := ts_Recovery(restart_ctr),
			selectionMode := {
				type_gtpc := '0F'O,
				selectModeValue := '00'B,
				spare := '111111'B
			},
			teidDataI := {
				type_gtpc := '00'O,
				teidDataI := teid_data
			},
			teidControlPlane := {
				type_gtpc := '00'O,
				teidControlPlane := teid_ctrl
			},
			nsapi := {
				type_gtpc := '00'O,
				nsapi := nsapi,
				unused := '0000'B
			},
			linked_nsapi := omit,
			charging_char := omit,
			trace_ref := omit,
			trace_type := omit,
			endUserAddress := eua,
			accessPointName := ts_APN(apn),
			protConfigOptions := pco,
			sgsn_addr_signalling := ts_GsnAddr(sgsn_ip_sign),
			sgsn_addr_traffic := ts_GsnAddr(sgsn_ip_data),
			msisdn := ts_Msisdn(msisdn),
			qualityOfServiceProfile := ts_QosDefault,
			tft := omit,
			triggerId := omit,
			omcId := omit,
			commonFlags := omit,
			aPN_Restriction := omit,
			ratType := omit,
			userLocationInformation := omit,
			mS_TimeZone := omit,
			imeisv := omit,
			camelChargingInformationContainer := omit,
			additionalTraceInfo := omit,
			correlationID := omit,
			evolvedAllocationRetentionPriorityI := omit,
			extendedCommonFlags := omit,
			userCSGInformation := omit,
			aPN_AMBR := omit,
			signallingPriorityIndication := omit,
			cN_OperatorSelectionEntity := omit,
			private_extension_gtpc := omit
		}
	}

	template Gtp1cUnitdata ts_GTPC_CreatePDP(GtpPeer peer, uint16_t seq, hexstring imsi,
						 OCT1 restart_ctr, OCT4 teid_data,
						 OCT4 teid_ctrl, BIT4 nsapi, EndUserAddress eua,
						 octetstring apn, octetstring sgsn_ip_sign,
						 octetstring sgsn_ip_data, octetstring msisdn,
						 template ProtConfigOptions pco := omit) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(createPDPContextRequest, '00000000'O,
					valueof(ts_CreatePdpPDU(imsi, restart_ctr, teid_data, teid_ctrl,
								nsapi, eua, apn, sgsn_ip_sign,
								sgsn_ip_data, msisdn, pco)), seq)
	}

	/* PCO send base template */
	template ProtConfigOptions ts_PCO := {
		type_gtpc := '84'O,
		lengthf := 0,
		configProtocol := '000'B,
		spare := '0000'B,
		extension0 := '1'B,
		protocols := {}
	}
	/* PCO receive base template */
	template ProtConfigOptions tr_PCO := {
		type_gtpc := '84'O,
		lengthf := ?,
		configProtocol := '000'B,
		spare := ?,
		extension0 := '1'B,
		protocols := {}
	}

	template ProtConfigOptions ts_PCO_IPv6_DNS modifies ts_PCO := {
		protocols := {
			{ protocolID := '0003'O, lengthProtoID := 0, protoIDContents := ''O }
		}
	}
	template ProtConfigOptions tr_PCO_IPv6_DNS_resp(template OCT16 contents) modifies tr_PCO := {
		protocols := {
			*, { protocolID := '0003'O, lengthProtoID := 16, protoIDContents := contents }, *
		}
	}

	template ProtConfigOptions ts_PCO_IPv4_DNS_IPCP modifies ts_PCO := {
		protocols := {
			/* dummy PAP entry to check if our parser in the GGSN can properly iterate over
			 * the list of protocols, see Change-Id Icc2e6716c33d78d3c3e000f529806228d8aa155e */
			{ protocolID := 'C023'O, lengthProtoID := 0, protoIDContents := ''O },
			{ protocolID := '8021'O, lengthProtoID := 16, protoIDContents :=
								enc_IpcpPacket(valueof(ts_IPCP_ReqDNS)) }
		}
	}

	template ProtocolElement tr_PCO_Proto(OCT2 prot_id) := {
		protocolID := prot_id,
		lengthProtoID := ?,
		protoIDContents := ?
	}
	template ProtConfigOptions tr_PCO_Contains(OCT2 prot_id) modifies tr_PCO := {
		protocols := { *, tr_PCO_Proto(prot_id), * }
	}

	template ProtConfigOptions ts_PCO_IPv4_DNS_CONT modifies ts_PCO := {
		protocols := {
			{ protocolID := '000d'O, lengthProtoID := 0, protoIDContents := ''O }
		}
	}
	template ProtConfigOptions tr_PCO_IPv4_DNS_CONT_resp(template OCT4 contents) modifies tr_PCO := {
		protocols := {
			*, { protocolID := '000d'O, lengthProtoID := 4, protoIDContents := contents }, *
		}
	}

	/* extract a given protocol payload from PCO */
	function f_PCO_extract_proto(ProtConfigOptions pco, OCT2 protocol, integer nth_match := 1) return octetstring {
		var integer i;
		var integer num_matches := 0;
		for (i := 0; i < lengthof(pco.protocols); i := i + 1) {
			if (pco.protocols[i].protocolID == protocol) {
				num_matches := num_matches + 1;
				if (num_matches == nth_match) {
					return pco.protocols[i].protoIDContents;
				}
			}
		}
		setverdict(fail);
		return ''O;
	}

	template IpcpPacket tr_IPCP(template LcpCode code, template uint8_t identifier,
				    template IpcpOptionList opts) := {
		code := code,
		identifier := identifier,
		len := ?,
		options := opts
	}
	template IpcpOption tr_IPCP_PrimaryDns(template OCT4 addr) := {
		code := IPCP_OPT_PrimaryDNS,
		len := 6,
		data := addr
	}
	template IpcpOption tr_IPCP_SecondaryDns(template OCT4 addr) := {
		code := IPCP_OPT_SecondaryDNS,
		len := 6,
		data := addr
	}
	template IpcpPacket tr_IPCP_Ack_DNS(template uint8_t identifier := ?, template OCT4 dns1 := ?,
					    template OCT4 dns2 := ?) :=
		tr_IPCP(LCP_Configure_Ack, identifier,
				{ *, tr_IPCP_PrimaryDns(dns1), *, tr_IPCP_SecondaryDns(dns2), * });

	template IpcpPacket ts_IPCP(LcpCode code, uint8_t identifier, template IpcpOptionList opts) := {
		code := code,
		identifier := identifier,
		len := 0,	/* overwritten */
		options := opts
	}
	template IpcpPacket ts_IPCP_ReqDNS(uint8_t identifier := 0) :=
		ts_IPCP(LCP_Configure_Request, identifier,
			{ tr_IPCP_PrimaryDns('00000000'O), tr_IPCP_SecondaryDns('00000000'O) });

	function f_teardown_ind_IE(in template BIT1 ind) return template TearDownInd {
/*
		if (not isvalue(ind)) {
			return omit;
		}
*/
		var TearDownInd ret := {
			type_gtpc := '13'O,
			tdInd := valueof(ind),
			spare:= '0000000'B
		}
		return ret;
	}

	template GTPC_PDUs ts_DeletePdpPDU(BIT4 nsapi, template BIT1 teardown_ind) := {
		deletePDPContextRequest := {
			cause := omit,
			tearDownIndicator := f_teardown_ind_IE(teardown_ind),
			nsapi := {
				type_gtpc := '14'O,
				nsapi := nsapi,
				unused := '0000'B
			},
			protConfigOptions := omit,
			userLocationInformation := omit,
			mS_TimeZone := omit,
			extendedCommonFlags := omit,
			uLI_Timestamp := omit,
			private_extension_gtpc := omit
		}
	}

	template Gtp1cUnitdata ts_GTPC_DeletePDP(GtpPeer peer, uint16_t seq, OCT4 teid,
						 BIT4 nsapi, template BIT1 teardown_ind) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(deletePDPContextRequest, teid,
					valueof(ts_DeletePdpPDU(nsapi, teardown_ind)), seq)
	}


	/* GTP-U */

	template PDU_GTPU tr_GTP1U_PDU(template OCT1 msg_type, template OCT4 teid, template GTPU_IEs ies := ?) := {
		pn_bit := ?,
		s_bit := ?,
		e_bit := ?,
		spare := ?,
		/* Protocol Type flag (PT) shall be set to '1' in GTP */
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := ?,
		teid := teid,
		opt_part := *,
		gtpu_IEs := ies
	}

	/* generalized GTP-U send template */
	template PDU_GTPU ts_GTP1U_PDU(OCT1 msg_type, uint16_t seq, OCT4 teid, GTPU_IEs ies) := {
		/* N-PDU Number flag (PN): the GTP-U header contains a meaningful N-PDU Number field if the PN
		 * flag is set to 1. */
		pn_bit := '0'B,	/* we assume the encoder overwrites this if an optional part is given */
		/* If the Sequence Number flag (S) is set to '1' the sequence number field is present and
		 * meaningful otherwise it is set to '0'. For GTP-U messages Echo Request, Echo Response,
		 * Error Indication and Supported Extension Headers Notification, the S flag shall be set to '1'. */
		s_bit := '1'B, 	/* we assume the encoder overwrites this if an optional part is given */
		/* Extension header presence */
		e_bit := '0'B,
		spare := '0'B,
		/* Protocol Type flag (PT) shall be set to '1' in GTP */
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := 0,	/* we assume encoder overwrites this */
		teid := teid,
		opt_part :=  {
			sequenceNumber := int2oct(seq, 2),
			npduNumber := '00'O,
			nextExtHeader := '00'O,
			gTPU_extensionHeader_List := omit
		},
		gtpu_IEs := ies
	}

	template Gtp1uUnitdata tr_GTPU_MsgType(template GtpPeer peer, template OCT1 msg_type, template OCT4 teid) := {
		peer := peer,
		gtpu := tr_GTP1U_PDU(msg_type, teid)
	}


	/* template matching reception of GTP-U echo-request */
	template Gtp1uUnitdata tr_GTPU_PING(template GtpPeer peer) := tr_GTPU_MsgType(peer, echoRequest, '00000000'O);

	/* template matching reception of GTP-U GPDU */
	template GTPU_IEs t_GPDU(template octetstring data) := {
		g_PDU_IEs := {
			data := data
		}
	}
	template Gtp1uUnitdata tr_GTPU_GPDU(template GtpPeer peer, template OCT4 teid, template octetstring data := ?) := {
		peer := peer,
		gtpu := tr_GTP1U_PDU('FF'O, teid, t_GPDU(data))
	}

	template GTPU_IEs ts_UEchoRespPDU(OCT1 restart_counter) := {
		echoResponse_IEs := {
			recovery_gtpu := {
				type_gtpu := '00'O, /* we assume encoder fixes? */
				restartCounter := restart_counter
			},
			private_extension_gtpu := omit
		}
	}

	/* master template for sending a GTP-U echo response */
	template Gtp1uUnitdata ts_GTPU_PONG(GtpPeer peer, uint16_t seq, OCT1 rest_ctr) := {
		peer := peer,
		gtpu := ts_GTP1U_PDU(echoResponse, seq, '00000000'O, valueof(ts_UEchoRespPDU(rest_ctr)))
	}

	/* master template for sending a GTP-U user plane data */
	template Gtp1uUnitdata ts_GTP1U_GPDU(GtpPeer peer, uint16_t seq, OCT4 teid, octetstring data) := {
		peer := peer,
		gtpu := ts_GTP1U_PDU('FF'O, seq, teid, { g_PDU_IEs := { data := data }})
	}

	/* Altstep implementing responses to any incoming echo requests */
	altstep pingpong() runs on GT_CT {
		var Gtp1cUnitdata ud;
		var Gtp1uUnitdata udu;
		[] GTPC.receive(tr_GTPC_PING(?)) -> value ud {
			var uint16_t seq := oct2int(ud.gtpc.opt_part.sequenceNumber);
			GTPC.send(ts_GTPC_PONG(ud.peer, seq, '00'O));
			repeat;
		};
		[] GTPU.receive(tr_GTPU_PING(?)) -> value udu {
			var uint16_t seq := oct2int(udu.gtpu.opt_part.sequenceNumber);
			GTPU.send(ts_GTPU_PONG(udu.peer, seq, '00'O));
		};
		[] T_default.timeout { setverdict(fail); };
	}

	/* 'internet' in DNS encoding */
	const octetstring c_ApnInternet := '08696E7465726E6574'O;
	const octetstring c_ApnInet6 := '05696E657436'O;
	const octetstring c_ApnInet46 := '06696E65743436'O;

	/* return random NSAPI */
	function f_rnd_nsapi() return BIT4 {
		return int2bit(f_rnd_int(16), 4);
	}

	/* return random TEI[DC] */
	function f_rnd_tei() return OCT4 {
		return int2oct(f_rnd_int(4294967296), 4);
	}

	/* define an (internal) representation of a PDP context */
	template PdpContext t_DefinePDP(hexstring imsi, octetstring msisdn, octetstring apn,
					EndUserAddress eua) := {
		imsi := imsi,
		msisdn := msisdn,
		nsapi := f_rnd_nsapi(),
		apn := apn,
		pco_req := omit,
		eua := eua,
		teid := f_rnd_tei(),
		teic := f_rnd_tei()
	}

	/* send GTP-C for a given context and increment sequence number */
	function f_send_gtpc(in template Gtp1cUnitdata data) runs on GT_CT {
		GTPC.send(data);
		g_c_seq_nr := g_c_seq_nr + 1;
	}

	/* send GTP-U for a given context and increment sequence number */
	function f_send_gtpu(inout PdpContext ctx, in octetstring data) runs on GT_CT {
		GTPU.send(ts_GTP1U_GPDU(g_peer_u, g_d_seq_nr, ctx.teid_remote, data));
		g_d_seq_nr := g_d_seq_nr + 1;
	}

	/* send a PDP context activation */
	function f_pdp_ctx_act(inout PdpContext ctx) runs on GT_CT {
		var Gtp1cUnitdata ud;
		var default d;

		log("sending CreatePDP");
		f_send_gtpc(ts_GTPC_CreatePDP(g_peer_c, g_c_seq_nr, ctx.imsi, g_restart_ctr,
						  ctx.teid, ctx.teic, ctx.nsapi, ctx.eua, ctx.apn,
						  g_sgsn_ip_c, g_sgsn_ip_u, ctx.msisdn, ctx.pco_req));
		T_default.start;
		d := activate(pingpong());
		alt {
			[] GTPC.receive(tr_GTPC_MsgType(g_peer_c, createPDPContextResponse, ctx.teic)) -> value ud {
				var CreatePDPContextResponse cpr := ud.gtpc.gtpc_pdu.createPDPContextResponse;
				if (cpr.cause.causevalue == '80'O) {
					/*  Check if EUA type corresponds to requested type */
					if (match(ctx.eua, t_EuaIPv4(?)) and
					    not match(cpr.endUserAddress, tr_EuaIPv4(?))){
						setverdict(fail);
					}
					if (match(ctx.eua, t_EuaIPv6(?)) and
					    not match(cpr.endUserAddress, tr_EuaIPv6(?))) {
						setverdict(fail);
					}
					/* Check if PCO response corresponds to request */
					if (ispresent(ctx.pco_req)) {
						if (match(ctx.pco_req, ts_PCO_IPv4_DNS_CONT) and
						    not match(cpr.protConfigOptions, tr_PCO_IPv4_DNS_CONT_resp(?))) {
							log("IPv4 DNS Container requested, but missing");
							setverdict(fail);
						}
						if (match(ctx.pco_req, ts_PCO_IPv6_DNS) and
						    not match(cpr.protConfigOptions, tr_PCO_IPv6_DNS_resp(?))) {
							log("IPv6 DNS Container requested, but missing");
							setverdict(fail);
						}
					}
					ctx.teid_remote := cpr.teidDataI.teidDataI;
					ctx.teic_remote := cpr.teidControlPlane.teidControlPlane;
					ctx.eua := cpr.endUserAddress;
					ctx.pco_neg := cpr.protConfigOptions;
					setverdict(pass);
				} else {
					setverdict(fail);
				}
			}
		}
		deactivate(d);
		T_default.stop;
	}

	function f_pdp_ctx_del(PdpContext ctx, template BIT1 teardown_ind) runs on GT_CT {
		var Gtp1cUnitdata ud;
		var default d;

		f_send_gtpc(ts_GTPC_DeletePDP(g_peer_c, g_c_seq_nr, ctx.teic_remote, ctx.nsapi, teardown_ind));
		T_default.start;
		d := activate(pingpong());
		alt {
			[] GTPC.receive(tr_GTPC_MsgType(g_peer_c, deletePDPContextResponse, ctx.teic)) -> value ud {
				if (ud.gtpc.gtpc_pdu.deletePDPContextResponse.cause.causevalue == '80'O) {
					setverdict(pass);
				} else {
					setverdict(fail);
				}
			}
		}
		deactivate(d);
		T_default.stop;
	}
	/* IPv6 router solicitation  fe80::2 -> ff02::2 from 02:88:b5:1f:25:59 */
	const octetstring c_router_solicit := '6000000000103afffe800000000000000000000000000002ff02000000000000000000000000000285009f2b0000000001010288b51f2559'O;
	/* IPv6 neighbor solicitation fe80::2 -> ff02::1:ff00:2 from 02:88:b5:1f:25:59 */
	const octetstring c_neigh_solicit:= '6000000000203afffe800000000000000000000000000002ff0200000000000000000001ff00000287009f9600000000fe80000000000000000000000000000201010288b51f2559'O;

	/* template to generate a 'Prefix Information' ICMPv6 option */
	template OptionField ts_ICMP6_OptPrefix(OCT16 prefix, INT1 prefix_len) := {
		prefixInformation := {
			typeField := 3,
			lengthIndicator := 8,
			prefixLength := prefix_len,
			reserved1 := '000000'B,
			a_Bit := '0'B,
			l_Bit := '0'B,
			validLifetime := oct2int('FFFFFFFF'O),
			preferredLifetime := oct2int('FFFFFFFF'O),
			reserved2 := '00000000'O,
			prefix := prefix
		}
	}

	/* template for an ICMPv6 router solicitation */
	template PDU_ICMPv6 ts_ICMPv6_RS := {
		routerSolicitation := {
			typeField := 133,
			code := 0,
			checksum := '0000'O,
			reserved := '00000000'O,
			/* TODO: do we need 'Source link-layer address' ? */
			options := omit
		}
	}

	/* template for an ICMPv6 router advertisement */
	template PDU_ICMPv6 ts_ICMPv6_RA(OCT16 prefix, INT1 prefix_len) := {
		routerAdvertisement := {
			typeField := 134,
			code := 0,
			checksum := '0000'O,
			curHopLimit := ?,
			reserved := '000000'B,
			o_Bit := '0'B,
			m_Bit := '0'B,
			routerLifetime := oct2int('FFFF'O),
			reachableTime := oct2int('FFFFFFFF'O),
			retransTimer := oct2int('FFFFFFFF'O),
			options := {
				ts_ICMP6_OptPrefix(prefix, prefix_len)
			}
		}
	}

	template PDU_ICMPv6 ts_ICMPv6_NS(OCT16 target_addr) := {
		neighborSolicitation := {
			typeField := 135,
			code := 0,
			checksum := '0000'O,
			reserved := '00000000'O,
			targetAddress := target_addr,
			/* TODO: do we need 'Source link-layer address' ? */
			options := omit
		}
	}

	/* derive ICMPv6 link-local address from lower 64bit of link_id */
	/* template for receiving/matching an ICMPv6 'Prefix Information' option */
	template OptionField tr_ICMP6_OptPrefix(template OCT16 prefix, template INT1 prefix_len) := {
		prefixInformation := {
			typeField := 3,
			lengthIndicator := 4,
			prefixLength := prefix_len,
			reserved1 := ?,
			a_Bit := ?,
			l_Bit := ?,
			validLifetime := ?,
			preferredLifetime := ?,
			reserved2 := ?,
			prefix := prefix
		}
	}

	/* template for receiving/matching an ICMPv6 router advertisement */
	template PDU_ICMPv6 tr_ICMPv6_RA(template OCT16 prefix, template INT1 prefix_len) := {
		routerAdvertisement := {
			typeField := 134,
			code := 0,
			checksum := ?,
			curHopLimit := ?,
			reserved := ?,
			o_Bit := '0'B,
			m_Bit := '0'B,
			routerLifetime := ?,
			reachableTime := ?,
			retransTimer := ?,
			options := {
				tr_ICMP6_OptPrefix(prefix, prefix_len)
			}
		}
	}

	/* template to construct IPv6_packet from input arguments, ready for use in f_IPv6_enc() */
	template IPv6_packet ts_IP6(OCT16 srcaddr, OCT16 dstaddr, LIN1 nexthead, octetstring payload, LIN1 hlim := 255) := {
		header := {
			ver := 6,
			trclass := 0,
			flabel := 0,
			plen := 0,
			nexthead := nexthead,
			hlim := hlim,
			srcaddr := srcaddr,
			dstaddr := dstaddr
		},
		ext_headers := omit,
		payload := payload
	}

	function f_ipv6_link_local(in OCT16 link_id) return OCT16 {
		 return 'FE80000000000000'O & substr(link_id, 8, 8);
	}

	/* Compute solicited-node multicast address as per RFC4291 2.7.1 */
	function f_ipv6_sol_node_mcast(in OCT16 addr) return OCT16 {
		return 'FF0200000000000000000001FF'O & substr(addr, 13, 3);
	}

	/* generate and encode ICMPv6 router solicitation */
	function f_gen_icmpv6_router_solicitation(in OCT16 link_id) return octetstring {
		const OCT16 c_ip6_all_router_mcast := 'FF020000000000000000000000000002'O;
		var OCT16 saddr := f_ipv6_link_local(link_id);

		var octetstring tmp;
		tmp := f_enc_PDU_ICMPv6(valueof(ts_ICMPv6_RS), saddr, c_ip6_all_router_mcast);
		var IPv6_packet ip6 := valueof(ts_IP6(saddr, c_ip6_all_router_mcast, 58, tmp));

		return f_IPv6_enc(ip6);
	}

	/* create ICMPv6 router solicitation deriving link-id from PDP Context EUA */
	function f_icmpv6_rs_for_pdp(in PdpContext ctx) return octetstring {
		var OCT16 interface_id := ctx.eua.endUserAddress.endUserAddressIPv6.ipv6_address;
		return f_gen_icmpv6_router_solicitation(interface_id);
	}

	/* generate and encode ICMPv6 neighbor solicitation */
	function f_gen_icmpv6_neigh_solicit(in OCT16 saddr, in OCT16 daddr, in OCT16 tgt_addr) return octetstring {
		var octetstring tmp;
		tmp := f_enc_PDU_ICMPv6(valueof(ts_ICMPv6_NS(tgt_addr)), saddr, daddr);
		var IPv6_packet ip6 := valueof(ts_IP6(saddr, daddr, 58, tmp));
		return f_IPv6_enc(ip6);
	}

	/* generate and encode ICMPv6 neighbor solicitation for PDP Context */
	function f_gen_icmpv6_neigh_solicit_for_pdp(in PdpContext ctx) return octetstring {
		var OCT16 interface_id := ctx.eua.endUserAddress.endUserAddressIPv6.ipv6_address;
		var OCT16 link_local := f_ipv6_link_local(interface_id);
		var OCT16 daddr := f_ipv6_sol_node_mcast(link_local);

		return f_gen_icmpv6_neigh_solicit(link_local, daddr, link_local);
	}

	/* wait for GGSN to send us an ICMPv6 router advertisement */
	function f_wait_rtr_adv(PdpContext ctx) runs on GT_CT {
		var Gtp1uUnitdata ud;
		T_default.start;
		alt {
			//'6???????????3aff'O
			[] GTPU.receive(tr_GTPU_GPDU(g_peer_u, ?)) -> value ud {
				var octetstring gpdu := ud.gtpu.gtpu_IEs.g_PDU_IEs.data;
				var IPv6_packet ip6 := f_IPv6_dec(gpdu);
				if (ip6.header.ver != 6 or ip6.header.nexthead != 58 or ip6.header.hlim != 255) {
					repeat;
				}
				var PDU_ICMPv6 icmp6 := f_dec_PDU_ICMPv6(ip6.payload);
				if (not match(icmp6, tr_ICMPv6_RA(?, 64))) {
					repeat;
				}
				ctx.ip6_prefix := icmp6.routerAdvertisement.options[0].prefixInformation.prefix;
				log("RA with /64 prefix ", ctx.ip6_prefix);
			}
			[] GTPU.receive(tr_GTPU_GPDU(?, ?)) { repeat; }
			[] GTPU.receive { setverdict(fail); }
			[] T_default.timeout { setverdict(fail); }
		}
		T_default.stop;
	}

	/* Test IPv6 context activation for dynamic IPv6 EUA without request of IPv6 DNS */
	testcase TC_pdp6_act_deact() runs on GT_CT {
		f_init();

		var PdpContext ctx := valueof(t_DefinePDP(f_rnd_imsi('26242'H), '1234'O, c_ApnInet6, valueof(t_EuaIPv6Dyn)));
		f_pdp_ctx_act(ctx);
		f_pdp_ctx_del(ctx, '1'B);
	}

	/* Test IPv6 context activation for dynamic IPv6 EUA wirh request of IPv6 DNS in PCO */
	testcase TC_pdp6_act_deact_pcodns() runs on GT_CT {
		f_init();

		var PdpContext ctx := valueof(t_DefinePDP(f_rnd_imsi('26242'H), '1234'O, c_ApnInet6, valueof(t_EuaIPv6Dyn)));
		ctx.pco_req := valueof(ts_PCO_IPv6_DNS);
		f_pdp_ctx_act(ctx);

		/* verify PCO contains both primary and secondary DNS */
		var OCT4 ggsn_ip6_dns1 := f_inet6_addr(m_ggsn_ip6_dns1);
		if (not match(f_PCO_extract_proto(ctx.pco_neg, '0003'O, 1), ggsn_ip6_dns1)) {
				setverdict(fail, "Primary DNS IPv6 PCO option not found");
		}

		var OCT4 ggsn_ip6_dns2 := f_inet6_addr(m_ggsn_ip6_dns2);
		if (not match(f_PCO_extract_proto(ctx.pco_neg, '0003'O, 2), ggsn_ip6_dns2)) {
				setverdict(fail, "Secondary DNS IPv6 PCO option not found");
		}

		f_pdp_ctx_del(ctx, '1'B);
	}

	/* Test PDP context activation for dynamic IPv6 EUA with IPv6 DNS in PCO and router solicitation/advertisement */
	testcase TC_pdp6_act_deact_icmp6() runs on GT_CT {
		f_init();

		var PdpContext ctx := valueof(t_DefinePDP(f_rnd_imsi('26242'H), '1234'O, c_ApnInet6, valueof(t_EuaIPv6Dyn)));
		ctx.pco_req := valueof(ts_PCO_IPv6_DNS);
		f_pdp_ctx_act(ctx);

		//f_send_gtpu(ctx, c_router_solicit);
		//f_send_gtpu(ctx, c_neigh_solicit);

		f_send_gtpu(ctx, f_icmpv6_rs_for_pdp(ctx));
		f_wait_rtr_adv(ctx);
		f_send_gtpu(ctx, f_gen_icmpv6_neigh_solicit_for_pdp(ctx));

		f_pdp_ctx_del(ctx, '1'B);
	}

	/* Test PDP context activation for dynamic IPv4 EUA without DNS request */
	testcase TC_pdp4_act_deact() runs on GT_CT {
		f_init();
		var PdpContext ctx := valueof(t_DefinePDP(f_rnd_imsi('26242'H), '1234'O, c_ApnInternet, valueof(t_EuaIPv4Dyn)));
		f_pdp_ctx_act(ctx);
		f_pdp_ctx_del(ctx, '1'B);
	}

	/* Test PDP context activation for dynamic IPv4 EUA with IPv4 DNS in IPCP */
	testcase TC_pdp4_act_deact_ipcp() runs on GT_CT {
		f_init();
		var OCT4 ggsn_ip4_dns1 := f_inet_addr(m_ggsn_ip4_dns1);
		var OCT4 ggsn_ip4_dns2 := f_inet_addr(m_ggsn_ip4_dns2);
		var PdpContext ctx := valueof(t_DefinePDP(f_rnd_imsi('26242'H), '1234'O, c_ApnInternet, valueof(t_EuaIPv4Dyn)));
		ctx.pco_req := valueof(ts_PCO_IPv4_DNS_IPCP);
		f_pdp_ctx_act(ctx);
		/* verify IPCP is at all contained */
		if (not match(ctx.pco_neg, tr_PCO_Contains('8021'O))) {
			setverdict(fail, "IPCP not found in PCO");
		}
		/* verify IPCP contains both primary and secondary DNS */
		var IpcpPacket ipcp := dec_IpcpPacket(f_PCO_extract_proto(ctx.pco_neg, '8021'O));
		if (not match(ipcp, tr_IPCP_Ack_DNS(0, ggsn_ip4_dns1, ggsn_ip4_dns2))) {
			if (not match(ipcp, tr_IPCP_Ack_DNS(0))) {
				setverdict(fail, "Primary/Secondary DNS PCO IPCP option not found");
			} else {
				setverdict(fail, "Primary/Secondary DNS PCO IPCP option found but not matching expected values");
			}
		}
		f_pdp_ctx_del(ctx, '1'B);
	}

	/* Test PDP context activation for dynamic IPv4 EUA with IPv4 DNS in PCO */
	testcase TC_pdp4_act_deact_pcodns() runs on GT_CT {
		f_init();
		var PdpContext ctx := valueof(t_DefinePDP(f_rnd_imsi('26242'H), '1234'O, c_ApnInternet, valueof(t_EuaIPv4Dyn)));
		ctx.pco_req := valueof(ts_PCO_IPv4_DNS_CONT);
		f_pdp_ctx_act(ctx);

		/* verify PCO contains both primary and secondary DNS */
		var OCT4 ggsn_ip4_dns1 := f_inet_addr(m_ggsn_ip4_dns1);
		if (not match(f_PCO_extract_proto(ctx.pco_neg, '000d'O, 1), ggsn_ip4_dns1)) {
				setverdict(fail, "Primary DNS IPv4 PCO option not found");
		}

		var OCT4 ggsn_ip4_dns2 := f_inet_addr(m_ggsn_ip4_dns2);
		if (not match(f_PCO_extract_proto(ctx.pco_neg, '000d'O, 2), ggsn_ip4_dns2)) {
				setverdict(fail, "Secondary DNS IPv4 PCO option not found");
		}

		f_pdp_ctx_del(ctx, '1'B);
	}

	testcase TC_echo_req_resp() runs on GT_CT {
		f_init();
		f_send_gtpc(ts_GTPC_PING(g_peer_c, g_c_seq_nr));
		T_default.start;
		alt {
			[] GTPC.receive(tr_GTPC_PONG(g_peer_c)) { setverdict(pass); };
			[] GTPC.receive { repeat; };
			[] T_default.timeout { setverdict(fail); }
		}
		T_default.stop;
	}

	control {
		execute(TC_pdp4_act_deact());
		execute(TC_pdp4_act_deact_ipcp());
		execute(TC_pdp4_act_deact_pcodns());

		execute(TC_pdp6_act_deact());
		execute(TC_pdp6_act_deact_pcodns());
		execute(TC_pdp6_act_deact_icmp6());

		execute(TC_echo_req_resp());
	}
}
