module IPA_Emulation {

import from IPA_Types all;
import from IPA_CodecPort all;
import from IPA_CodecPort_CtrlFunct all;
import from IPL4asp_Types all;
import from MTP3asp_Types all;
import from MTP3asp_PortType all;

/*
modulepar {
}
*/

type enumerated IpaMode {
	IPA_MODE_CLIENT,
	IPA_MODE_SERVER
}

type record ASP_IPA_Unitdata {
	IpaStreamId	streamId,
	octetstring	payload
}

type port IPA_SP_PT message {
	inout ASP_IPA_Unitdata;
} with { extension "internal" }

type component IPA_Emulation_CT {
	/* down-facing port to IPA codec port */
	port IPA_CODEC_PT IPA_PORT;
	/* up-facing port to SCCP */
	port MTP3asp_SP_PT MTP3_SP_PORT;
	/* up-facing port for other streams */
	port IPA_SP_PT IPA_SP_PORT;

	var boolean g_initialized := false;
	var ConnectionId g_ipa_conn_id := -1;

	var IpaMode g_mode;
}

function f_connect(charstring remote_host, PortNumber remote_port,
		   charstring local_host, PortNumber local_port) runs on IPA_Emulation_CT {
	var Result res;
	res := IPA_CodecPort_CtrlFunct.f_IPL4_connect(IPA_PORT, remote_host, remote_port,
						local_host, local_port, 0, { tcp:={} });
	g_ipa_conn_id := res.connId;
}

function f_bind(charstring local_host, PortNumber local_port) runs on IPA_Emulation_CT {
	var Result res;
	res := IPA_CodecPort_CtrlFunct.f_IPL4_listen(IPA_PORT, 
						local_host, local_port, { tcp:={} });
	g_ipa_conn_id := res.connId;
}

template ASP_MTP3_TRANSFERind ts_MTP3_XFER_ind(integer opc, octetstring data) := {
	sio := { '10'B, '00'B, '0011'B },
	opc := opc,
	dpc := 0,
	sls := 0,
	data := data
}


private template IpaCcmRespPart t_IdRespPart(IpaCcmIdTag tag, charstring payload) := {
	len := 0,	/* overwritten by codec */
	tag := tag,
	data := payload
}

/* build IPA CCM ID RESP response from IPA CCM GET */
private function f_ccm_make_id_resp(PDU_IPA_CCM get) return PDU_IPA_CCM {
	var integer i;
	var PDU_IPA_CCM resp := {
		msg_type := IPAC_MSGT_ID_RESP,
		u := {
			resp := {}
		}
	}

	for (i := 0; i < sizeof(get.u.get); i := i + 1) {
		var IpaCcmIdTag tag := get.u.get[i].tag;
		var charstring foo;
		select (tag) {
			case (IPAC_IDTAG_UNIT) {
				foo := "0/1/2";
			}
			case (IPAC_IDTAG_UNITNAME) {
				foo := "mahlzeit";
			}
			case else {
				foo := "foo";
			}
		}
		resp.u.resp[sizeof(resp.u.resp)] := valueof(t_IdRespPart(tag, foo));
	}

	return resp;
}

/* transmit IPA CCM message */
private function f_ccm_tx(PDU_IPA_CCM ccm) runs on IPA_Emulation_CT {
	var IPA_Send ipa_tx := {
		connId := g_ipa_conn_id,
		streamId := IPAC_PROTO_CCM,
		msg := enc_PDU_IPA_CCM(ccm)
	}
	log("CCM Tx:", ccm);
	IPA_PORT.send(ipa_tx);
}

template PDU_IPA_CCM ts_IPA_PONG := {
	msg_type := IPAC_MSGT_PONG,
	u := omit
}

template PDU_IPA_CCM ts_IPA_ACK := {
	msg_type := IPAC_MSGT_ID_ACK,
	u := omit
}

template PDU_IPA_CCM ts_IPA_ID_GET := {
	msg_type := IPAC_MSGT_ID_GET,
	u := {
		get := {
			{ 1, IPAC_IDTAG_UNITNAME }
		}
	}
}

/* receive IPA CCM message */
private function f_ccm_rx(PDU_IPA_CCM ccm) runs on IPA_Emulation_CT {
	select (ccm.msg_type) {
		case (IPAC_MSGT_PING) {
			f_ccm_tx(valueof(ts_IPA_PONG));
		}
		case (IPAC_MSGT_ID_ACK) {
			f_ccm_tx(valueof(ts_IPA_ACK));
		}
		case (IPAC_MSGT_ID_GET) {
			f_ccm_tx(f_ccm_make_id_resp(ccm));
		}
		case else {
			log("Unknown/unsupported IPA CCM message type", ccm);
		}
	}
}

private function f_to_asp(IPA_RecvFrom ipa_rx) return ASP_IPA_Unitdata {
	var ASP_IPA_Unitdata ret := {
		streamId := ipa_rx.streamId,
		payload := ipa_rx.msg
	}
	return ret;
}

private function f_from_asp(ConnectionId connId, ASP_IPA_Unitdata ipa_tx) return IPA_Send {
	var IPA_Send ret := {
		connId := connId,
		streamId := ipa_tx.streamId,
		msg := ipa_tx.payload
	}
	return ret;
}

function main_client(charstring remote_host, PortNumber remote_port,
		     charstring local_host, PortNumber local_port) runs on IPA_Emulation_CT {
	g_mode := IPA_MODE_CLIENT;
	f_connect(remote_host, remote_port, local_host, local_port);
	ScanEvents();
}

function main_server(charstring local_host, PortNumber local_port) runs on IPA_Emulation_CT {
	g_mode := IPA_MODE_SERVER;
	f_bind(local_host, local_port);
	ScanEvents();
}

private function ScanEvents() runs on IPA_Emulation_CT {
	var IPA_RecvFrom ipa_rx;
	var ASP_IPA_Unitdata ipa_ud;
	var ASP_MTP3_TRANSFERreq mtp_req;
	var ASP_Event asp_evt;

	while (true) {
		alt {
		/* Received IPA -> up into SCCP stack */
		[] IPA_PORT.receive(IPA_RecvFrom: ?) -> value ipa_rx {
			select (ipa_rx.streamId) {
			case (IPAC_PROTO_CCM) {
				var PDU_IPA_CCM ccm := dec_PDU_IPA_CCM(ipa_rx.msg);
				log("CCM Rx:", ccm);
				f_ccm_rx(ccm);
				}
			case (IPAC_PROTO_SCCP) {
				var ASP_MTP3_TRANSFERind mtp;
				mtp := valueof(ts_MTP3_XFER_ind(0, ipa_rx.msg));
				MTP3_SP_PORT.send(mtp);
				}
			case else {
				IPA_SP_PORT.send(f_to_asp(ipa_rx));
				}
			}
		}

		/* server only */
		[] IPA_PORT.receive(ASP_Event:{connOpened:=?}) -> value asp_evt {
			log("IPA: Connected");
			g_ipa_conn_id := asp_evt.connOpened.connId;
			if (g_mode == IPA_MODE_SERVER) {
				f_ccm_tx(valueof(ts_IPA_ID_GET));
			}
		}

		[] IPA_PORT.receive(ASP_Event:{connClosed:=?}) -> value asp_evt {
			log("IPA: Closed");
			g_ipa_conn_id := -1;
			self.stop;
		}

		/* Received SCCP -> down into IPA */
		[] MTP3_SP_PORT.receive(ASP_MTP3_TRANSFERreq: ?) -> value mtp_req {
			var IPA_Send ipa_tx := {
				connId := g_ipa_conn_id,
				streamId := IPAC_PROTO_SCCP,
				msg := mtp_req.data
			}
			IPA_PORT.send(ipa_tx);
		}

		/* Received MISC (RSL/OML/CTRL/MGCP) -> down into IPA */
		[] IPA_SP_PORT.receive(ASP_IPA_Unitdata: ?) -> value ipa_ud {
			IPA_PORT.send(f_from_asp(g_ipa_conn_id, ipa_ud));
		}


		}
	}
}

}
