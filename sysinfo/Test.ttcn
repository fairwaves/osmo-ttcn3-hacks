module Test {
	import from GSM_SystemInformation all;
	import from GSMTAP_Types all;
	import from GSMTAP_PortType all;
	import from IPL4_GSMTAP_CtrlFunct all;
	import from TELNETasp_PortType all;

	const octetstring si1 := '5506198fb38000000000000000000000000000e504002b'O;
	const octetstring si2 := '59061a00000000000000000000000000000000ffe50400'O;
	const octetstring si3 := '49061b000062f22404d2490301275d40e50400392b2b2b'O;
	const octetstring si4 := '31061c62f22404d25d40e504002b2b2b2b2b2b2b2b2b2b'O;

	type component dummy_CT {
		port GSMTAP_PT GSMTAP;
		port TELNETasp_PT BSCVTY;
	};

	testcase TC_si1() runs on dummy_CT {
		var SystemInformationHeader hdr := {
			l2_plen := valueof(t_L2Pseudolength(21)),
			skip_indicator := 0,
			rr_protocol_discriminator := 6,
			message_type := '19'O
		};
		log("SI: ", dec_SystemInformation(si1));
		log("SI: ", dec_SystemInformation(si2));
		log("SI: ", dec_SystemInformation(si3));
		log("SI: ", dec_SystemInformation(si4));
	}

	template GsmtapHeader t_GsmtapHeader := {
		version := GSMTAP_VERSION,
		hdr_len := 4,
		msg_type := ?,
		timeslot := ?,
		arfcn := ?,
		signal_dbm := ?,
		snr_db := ?,
		frame_number := ?,
		sub_type := ?,
		antenna_nr := ?,
		sub_slot := ?,
		res := ?
	}

	template GsmtapHeader t_GsmtapHeaderUm(template GsmtapChannel ch) modifies t_GsmtapHeader := {
		msg_type := GSMTAP_TYPE_UM,
		sub_type := ch
	}


	template GsmtapMessage t_bcch := {
		header := t_GsmtapHeaderUm(GSMTAP_CHANNEL_BCCH),
		payload := ?
	}

	template GSMTAP_RecvFrom t_recvfrom(template GsmtapChannel ch) := {
		connId := ?,
		remName := ?,
		remPort := ?,
		locName := ?,
		locPort := GSMTAP_PORT,
		proto := {udp:={}},
		userData := ?,
		msg := { header := t_GsmtapHeaderUm(ch), payload := ?}
	}

	testcase TC_gsmtap() runs on dummy_CT {
		map(self:GSMTAP, system:GSMTAP);
		IPL4_GSMTAP_CtrlFunct.f_IPL4_listen(GSMTAP, "0.0.0.0", GSMTAP_PORT, {udp := {}});

		var GSMTAP_RecvFrom rf;
		GSMTAP.receive(t_recvfrom(GSMTAP_CHANNEL_BCCH)) -> value rf;
		log("UDP Rx:", rf);
		log("SI: ", dec_SystemInformation(rf.msg.payload));
	}



	/* permitted prompts on VTY */
	const charstring NORMAL_PROMPT := "OpenBSC> ";
	const charstring ENABLE_PROMPT := "OpenBSC# ";
	const charstring CONFIG_PROMPT := "OpenBSC(*)\#";

	const ASP_TelnetDynamicConfig vty_prompt[3] := {
		{
			prompt := {
				id := 1,
				prompt := NORMAL_PROMPT,
				has_wildcards := false
			}
		}, {
			prompt := {
				id := 2,
				prompt := ENABLE_PROMPT,
				has_wildcards := false
			}
		}, {
			prompt := {
				id := 3,
				prompt := CONFIG_PROMPT,
				has_wildcards := true
			}
		}
	};

	/* configure prompts in TELNETasp module */
	function f_vty_set_prompts(TELNETasp_PT pt) {
		/* set some configuration that isn't possible to express
		 * in the config file due to syntactic restrictions (Who invents config
		 * files that don't permit regular expressions? */
		for (var integer i := 0; i < sizeof(vty_prompt); i:= i + 1) {
			pt.send(vty_prompt[i])
		}
	}

	/* wait for any of the permitted prompts; buffer + return all intermediate output */
	function f_vty_wait_for_prompt(TELNETasp_PT pt) return charstring {
		template charstring config_pattern := pattern CONFIG_PROMPT;
		var charstring rx, buf := "";
		timer T := 2.0;

		T.start;
		alt {
			[] pt.receive(NORMAL_PROMPT) { };
			[] pt.receive(ENABLE_PROMPT) { };
			[] pt.receive(config_pattern) { };
			[] pt.receive(charstring:?) -> value rx { buf := buf & rx; repeat };
			[] T.timeout { setverdict(fail); return ""};
		}
		T.stop;
		return buf;
	}

	/* send a VTY command and obtain response until prompt is received */
	function f_vty_transceive(TELNETasp_PT pt, charstring tx) return charstring {
		pt.send(tx);
		return f_vty_wait_for_prompt(pt);
	}

	/* enter the'confiugration' mode of the VTY */
	function f_vty_enter_config(TELNETasp_PT pt) {
		f_vty_transceive(pt, "enable");
		f_vty_transceive(pt, "configure terminal")
	}

	testcase TC_telnet() runs on dummy_CT {

		map(self:BSCVTY, system:BSCVTY);
		f_vty_set_prompts(BSCVTY)

		f_vty_transceive(BSCVTY, "show network")
		f_vty_enter_config(BSCVTY)
		f_vty_transceive(BSCVTY, "network")
		f_vty_transceive(BSCVTY, "bts 0")
	}

	control {
		execute(TC_si1());
		execute(TC_gsmtap());
		execute(TC_telnet());
	}
}
