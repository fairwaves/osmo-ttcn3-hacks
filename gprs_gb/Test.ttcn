module Test {

	import from General_Types all;
	import from Osmocom_Types all;
	import from GSM_Types all;
	import from GSM_RR_Types all;
	import from Osmocom_Gb_Types all;
	import from BSSGP_Types all;
	import from BSSGP_Emulation all;
	import from NS_Types all;
	import from NS_Emulation all;
	import from LLC_Types all;
	import from LLC_Templates all;
	import from RLCMAC_Types all;
	import from RLCMAC_CSN1_Types all;
	import from LAPDm_RAW_PT all;

	modulepar {
		BssgpConfig mp_gb_cfg := {
			nsei := 1234,
			bvci := 1234,
			cell_id := {
				ra_id := {
					lai := {
						mcc_mnc := '26242F'H, lac := 13135
					},
					rac := 0
				},
				cell_id := 20960
			},
			sgsn_role := true
		};
	}

	type record MmContext {
		hexstring	imsi optional,
		GprsTlli	tlli,
		uint9_t		n_u
	};


	type component dummy_CT extends BSSGP_Client_CT {
		var lapdm_CT lapdm_component;
		port LAPDm_PT L1;

		var NS_CT ns_component;
		var BSSGP_CT bssgp_component;

		var MmContext g_mmctx := {
			tlli := 'FFFFFFFF'O,
			n_u := 0
		};

		var boolean g_initialized := false;
	}

	function f_init() runs on dummy_CT {
		if (g_initialized == true) {
			return;
		}
		g_initialized := true;
		/* create a new NS component */
		ns_component := NS_CT.create;
		bssgp_component := BSSGP_CT.create;
		/* connect our BSSGP port to the BSSGP Emulation */
		connect(self:BSSGP, bssgp_component:BSSGP_SP);
		connect(self:BSSGP_PROC, bssgp_component:BSSGP_PROC);
		/* connect lower-end of BSSGP with BSSGP_CODEC_PORT (maps to NS_PT*/
		connect(bssgp_component:BSCP, ns_component:NS_SP);
		/* connect lower-end of NS emulation to NS_CODEC_PORT (on top of IPl4) */
		map(ns_component:NSCP, system:NS_CODEC_PORT);
		ns_component.start(NSStart());
		bssgp_component.start(BssgpStart(mp_gb_cfg));

		lapdm_component := lapdm_CT.create;
		connect(self:L1, lapdm_component:LAPDM_SP);
		map(lapdm_component:L1CTL, system:L1CTL);
		lapdm_component.start(LAPDmStart());
	}

	function f_bssgp_dec_and_log(in octetstring inp) {
		log("BSSGP Input: ", inp);
		var PDU_BSSGP dec := dec_PDU_BSSGP(inp);
		log("BSSGP Decoded: ", dec);
	}

	testcase TC_selftest_bssgp() runs on dummy_CT {
		const octetstring c_bvc_reset_pcu := '2204820000078108088832f44000c80051e0'O;
		const octetstring c_bvc_reset_q := '2204820000078100'O;
		const octetstring c_status_pcu := '4107810515882204820000078103'O;
		const octetstring c_reset_ack_q := '2304820000'O;
		const octetstring c_reset_ack_pcu := '23048200c4'O;
		const octetstring c_unblock_pcu := '24048200c4'O;
		const octetstring c_unblock_ack_q := '25048200c4'O;
		const octetstring c_fc_bvc_pcu := '261e8101058200fa038200c8018200fa1c8200c806820000'O;
		const octetstring c_fc_bvc_ack_q := '271e8101'O;
		const octetstring c_gmm_mo_att_req := '01bb146ddd000004088832f44000c80051e000800e003b01c001080103e5e000110a0005f4fb146ddd32f44000c8001d1b53432b37159ef9090070000dd9c6321200e00019b32c642401c0002017057bf0ec'O;
		const octetstring c_gmm_mt_ac_req := '00bb146ddd0050001682ffff0a8204030e9c41c001081200102198c72477ea104895e8b959acc58b108182f4d045'O;
		const octetstring c_gmm_mo_ac_resp := '01bb146ddd000004088832f44000c80051e000800e000e01c00508130122fa361f5fdd623d'O;
		const octetstring c_gmm_mt_att_acc := '00bb146ddd0050001682ffff0a8204030e9841c005080201340432f44000c8001805f4fb146ddd0967d0'O;
		const octetstring c_gmm_mt_det_req := '00bb146ddd0050001682ffff0a8204030e8941c00908050215f0b6'O;
		const octetstring c_gmm_mo_att_cpl := '01fb146ddd000004088832f44000c80051e000800e000801c009080339d7bc'O;

		f_bssgp_dec_and_log(c_bvc_reset_pcu);
		f_bssgp_dec_and_log(c_bvc_reset_q);
		f_bssgp_dec_and_log(c_status_pcu);
		f_bssgp_dec_and_log(c_reset_ack_q);
		f_bssgp_dec_and_log(c_reset_ack_pcu);
		f_bssgp_dec_and_log(c_unblock_pcu);
		f_bssgp_dec_and_log(c_unblock_ack_q);
		f_bssgp_dec_and_log(c_fc_bvc_pcu);
		f_bssgp_dec_and_log(c_fc_bvc_ack_q);
		f_bssgp_dec_and_log(c_gmm_mo_att_req);
		f_bssgp_dec_and_log(c_gmm_mt_ac_req);
		f_bssgp_dec_and_log(c_gmm_mo_ac_resp);
		f_bssgp_dec_and_log(c_gmm_mt_att_acc);
		f_bssgp_dec_and_log(c_gmm_mt_det_req);
		f_bssgp_dec_and_log(c_gmm_mo_att_cpl);

		log(ts_BSSGP_PS_PAGING_IMSI(196, '262420123456789'H));
	}

	function f_ns_assert_prepr(in octetstring a, in octetstring b) {
		log("NS Input: ", a);
		log("NS Expected: ", b);

		if (a != b) {
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	function f_ns_dec_and_log(in octetstring inp) {
		log("NS Input: ", inp);
		var PDU_NS dec := dec_PDU_NS(inp);
		log("NS Decoded: ", dec);
	}

	testcase TC_selftest_ns() runs on dummy_CT {
		const octetstring c_ns_reset_pcu := '000000c4271e813d'O;

		/* single byte length to two byte length */
		f_ns_assert_prepr('04058101'O, '0405000101'O);
		f_ns_assert_prepr('040589000102030405060708'O, '04050009000102030405060708'O);
		/* two byte length to two byte length */
		f_ns_assert_prepr('0405000101'O, '0405000101'O);
		/* special case: NS-UNITDATA */
		f_ns_assert_prepr('00aabbccddeeffaa29822342'O, '00aabbccddeeffaa2900022342'O);
		/* multiple TLVs */
		f_ns_assert_prepr('234281aa4382bbbb'O, '23420001aa430002bbbb'O);
		/* zero-length */
		f_ns_assert_prepr('230080'O, '23000000'O);

		f_ns_dec_and_log(c_ns_reset_pcu);
	}

	const octetstring gmm_auth_req := '081200102198c72477ea104895e8b959acc58b108182'O;

	/* Wrap downlink GMM into LLC, encode + send it via BSSGP to PCU */
	function tx_gmm(BIT1 c_r, in octetstring gmm_pdu, BIT4 sapi := c_LLC_SAPI_LLGMM) runs on dummy_CT {
		var PDU_LLC llc;

		//log("GMM Tx: ", dec_PDU_L3_SGSN_MS(gmm_pdu));

		log(c_r, g_mmctx.n_u, gmm_pdu, sapi);
		llc := valueof(ts_LLC_UI(gmm_pdu, sapi, c_r, g_mmctx.n_u));
		log(llc);
		g_mmctx.n_u := g_mmctx.n_u + 1;

		log(ts_BSSGP_DL_UD(g_mmctx.tlli, enc_PDU_LLC(llc)));

		BSSGP.send(ts_BSSGP_DL_UD(g_mmctx.tlli, enc_PDU_LLC(llc)));
	}

	/* Establish BSSGP connection to PCU */
	function f_bssgp_establish() runs on dummy_CT {
		timer T:= 10.0;

		f_init();
		T.start
		alt {
			[] BSSGP.receive(t_BssgpStsInd(?, ?, BVC_S_UNBLOCKED)) { }
			[] BSSGP.receive { repeat; }
			[] T.timeout { setverdict(fail); }
		}
		T.stop
		log("BSSGP successfully initialized");
	}

	/* Send PS-PAGING via BSSGP to PCU, expect it to show up on L1/Um */
	testcase TC_paging() runs on dummy_CT {
		var hexstring imsi := '262420123456789'H;
		var BssgpBvci bvci := 196;
		var GsmTmsi tmsi := hex2int('01234567'H);

		f_bssgp_establish();

		BSSGP.send(ts_BSSGP_PS_PAGING_IMSI(bvci, imsi));
		BSSGP.send(ts_BSSGP_PS_PAGING_PTMSI(bvci, imsi, tmsi));

		while (true) {
			var BssgpDecoded bd;
			alt {
				[] BSSGP.receive(tr_BD_L3_MT(?)) -> value bd {
					log("BSSGP Rx: ", bd);
				}
				[] BSSGP.receive(t_BssgpStsInd(?, ?, BVC_S_UNBLOCKED)) { repeat; }
				[] BSSGP.receive { repeat; }
			}
		}
	}

	/* Establish an UL TBF: Tune to ARFCN, send RACH, receive AGCH, enable TBF Rx */
	function f_establish_ul_tbf() runs on dummy_CT {
		timer T := 5.0;
		var BCCH_tune_req tune_req := { { false, 871 }, true };
		L1.send(tune_req);
		/* FIXME: wait for confirm */

		var TBF_establish_req est_req := { ra := hex2int('7B'H) };
		L1.send(est_req);
		T.start;
		/* FIXME: wait for confirm */
		alt {
			[] L1.receive(TBF_establish_res:?) {}
			[] L1.receive { repeat; }
			[] T.timeout { setverdict(fail); }
		}
		T.stop;
	}

	/* Template fro uplink Data block */
	template RlcmacUlBlock t_RLCMAC_UL_DATA(template uint5_t tfi, template uint4_t cv, template uint7_t bsn,
						template LlcBlocks blocks := {}, template boolean stall := false) := {
		data := {
			mac_hdr := {
				payload_type := MAC_PT_RLC_DATA,
				countdown := cv,
				stall_ind := false,
				retry := false,
				spare := '0'B,
				pfi_ind := false,
				tfi := tfi,
				tlli_ind := false,
				bsn := bsn,
				e := false
			},
			tlli := omit,
			pfi := omit,
			blocks := blocks
		}
	}
	template RlcmacUlBlock t_RLCMAC_UL_DATA_TLLI(template uint5_t tfi, template uint4_t cv, template uint7_t bsn,
						     template LlcBlocks blocks := {}, template boolean stall := false, template GprsTlli tlli) := {
		data := {
			mac_hdr := {
				payload_type := MAC_PT_RLC_DATA,
				countdown := cv,
				stall_ind := false,
				retry := false,
				spare := '0'B,
				pfi_ind := false,
				tfi := tfi,
				tlli_ind := true,
				bsn := bsn,
				e := false
			},
			tlli := tlli,
			pfi := omit,
			blocks := blocks
		}
	}

	template DlMacHeader t_RLCMAC_DlMacH(template MacPayloadType pt, template MacRrbp rrbp, template
uint3_t usf) := {
		payload_type := pt,
		rrbp := rrbp,
		rrbp_valid := ispresent(rrbp),
		usf := usf
	}

	/* Receive Template for Downlink ACK/NACK */
	template RlcmacDlBlock tr_RLCMAC_ACK_NACK(template uint5_t ul_tfi, template GprsTlli tlli := ?) := {
		ctrl := {
			mac_hdr := {
				payload_type := (MAC_PT_RLCMAC_NO_OPT, MAC_PT_RLCMAC_OPT),
				rrbp:= ?,
				rrbp_valid := true,
				usf := ?
			},
			opt := *,
			payload := {
				msg_type := PACKET_UL_ACK_NACK,
				u := {
					ul_ack_nack := {
						page_mode := ?,
						msg_excape := ?,
						uplink_tfi := ul_tfi,
						is_egprs := '0'B,
						gprs := {
							ch_coding_cmd := ?,
							ack_nack_desc := ?,
							cont_res_tlli_present := ?,
							cont_res_tlli := tlli,
							pkt_ta_present := ?,
							pkt_ta := *,
							pwr_ctrl_present := ?,
							pwr_ctrl := *
						}
					}
				}
			}
		}
	}

	/* Template for Uplink MAC Control Header */
	template UlMacCtrlHeader t_RLCMAC_UlMacCtrlH(template MacPayloadType pt, template boolean retry := false) := {
		payload_type := pt,
		spare := '00000'B,
		retry := retry
	}

	/* Template for Uplink Conntrol ACK */
	template RlcmacUlBlock ts_RLCMAC_CTRL_ACK(GprsTlli tlli, CtrlAck ack := MS_RCVD_TWO_RLC_SAME_RTI_DIFF_RBSN) := {
		ctrl := {
			mac_hdr := t_RLCMAC_UlMacCtrlH(MAC_PT_RLCMAC_NO_OPT),
			payload := {
				msg_type := PACKET_CONTROL_ACK,
				u := {
					ctrl_ack := {
						tlli := tlli,
						ctrl_ack := ack
					}
				}
			}
		}
	}

	/* Template for a LlcBlock (part of a LLC frame inside RlcMac?lDataBlock */
	template LlcBlock t_RLCMAC_LLCBLOCK(octetstring data, BIT1 more := '0'B, boolean e := true) := {
		hdr := {
			length_ind := lengthof(data),
			more := more,
			e := e
		},
		payload := data
	}

	/* compute a random TLLI; FIXME: what about TLLI prefix / local/foreign/...? */
	function f_random_tlli() return GprsTlli {
		var GprsTlli tlli := f_rnd_octstring(4);
		return tlli;
	}

	/* Compute the frame number of the uplink block based on current fn + rrbp */
	function f_rrbp_fn(GsmFrameNumber fn, MacRrbp rrbp) return GsmFrameNumber {
		var integer add;
		select (rrbp) {
		case (RRBP_Nplus13_mod_2715648) {
			add := 13;
			}
		case (RRBP_Nplus17_or_18_mod_2715648) {
			add := 17; /* FIXME: What about 'or 18'? */
			}
		case (RRBP_Nplus21_or_22_mod_2715648) {
			add := 21; /* FIXME: What about 'or 22'? */
			}
		case (RRBP_Nplus26_mod_2715648) {
			add := 26;
			}
		}
		return (fn + add) mod 2715648;
	}

	/* Send a single Uplink Block via Um; Verify reception on BSSGP; Expect UL_ACK on Um */
	function f_single_ul_block(GprsCodingScheme cs) runs on dummy_CT {
		var octetstring payload := '01020304'O;
		var PDU_LLC llc := valueof(ts_LLC_UI(payload, c_LLC_SAPI_LLGMM, '0'B, g_mmctx.n_u));
		var octetstring llc_enc := enc_PDU_LLC(llc);
		var RLCMAC_ph_data_ind dl;

		/* establish upling TBF */
		f_establish_ul_tbf();

		/* Generate LLC PDU consisting of single RLC block and send it via simulated MS */
		var template RlcmacUlBlock blk := t_RLCMAC_UL_DATA_TLLI(0, 0, 0, {t_RLCMAC_LLCBLOCK(llc_enc)}, false, g_mmctx.tlli);
		L1.send(RLCMAC_ph_data_req:{dyn:={tbf_id := 0, cs := cs, block := blk}});
		/* ensure that this LLC-PDU arrives from the right TLLI at the (simulated) SGSN */
		BSSGP.receive(tr_BD_BSSGP(tr_BSSGP_UL_UD(g_mmctx.tlli, ?, llc_enc)));

		/* ensure the MS eceives an UL_ACK_NACK */
		alt {
		[] L1.receive(RLCMAC_ph_data_ind:{cs:=?, ts_nr:=?, fn:=?, block:=tr_RLCMAC_ACK_NACK(0, g_mmctx.tlli)}) -> value dl {
			log("found matching ACK/NACK");
			/* send CTRL ACK in uplink */
			var GsmFrameNumber ul_fn := f_rrbp_fn(dl.fn, dl.block.ctrl.mac_hdr.rrbp);
			var RlcmacUlCtrlMsg ctrl_ack := valueof(ts_RlcMacUlCtrl_PKT_CTRL_ACK(g_mmctx.tlli));
			var RlcmacUlBlock ul_block := valueof(ts_RLC_UL_CTRL_ACK(ctrl_ack));
			L1.send(ts_PH_DATA_ABS(0, CS1, dl.ts_nr, ul_fn, {false, 0}, ul_block));
			}
		[] L1.receive { repeat; };
		}
	}

	testcase TC_rach() runs on dummy_CT {
		var BssgpBvci bvci := 196;
		g_mmctx.imsi := '262420123456789'H;
		g_mmctx.tlli := f_random_tlli();

		f_init();

		f_bssgp_client_register(g_mmctx.imsi, g_mmctx.tlli, mp_gb_cfg.cell_id);

		f_bssgp_establish();

		f_single_ul_block(CS1);

		while (true) {
			var BssgpDecoded bd;
			var RLCMAC_ph_data_ind dl_msg;
			alt {

				[] BSSGP.receive(tr_BD_BSSGP(?)) -> value bd {
					log("BSSGP Rx: ", bd);
				}
				[] BSSGP.receive(t_BssgpStsInd(?, ?, BVC_S_UNBLOCKED)) { repeat; }
				[] BSSGP.receive { repeat; }

				[] L1.receive(RLCMAC_ph_data_ind:?) -> value dl_msg {
					log("L1 DL: ", dl_msg);
				}
			}
		}
	}


	testcase TC_nsem() runs on dummy_CT {

		f_bssgp_establish();

		while (true) {
			var BssgpDecoded bd;
			alt {
				[] BSSGP.receive(tr_BD_BSSGP(?)) -> value bd {
					log("BSSGP Rx: ", bd);
					//log("GMM Rx: ", dec_PDU_L3_MS_SGSN(pdu.payload));
					g_mmctx.tlli := bd.bssgp.pDU_BSSGP_UL_UNITDATA.tLLI;
					tx_gmm(LLC_CR_DL_CMD, gmm_auth_req);
				}
				[] BSSGP.receive(t_BssgpStsInd(?, ?, BVC_S_UNBLOCKED)) { repeat; }
				[] BSSGP.receive { repeat; }
			}
		}
	}


	function f_llc_dec_and_log(in octetstring inp) {
		log("LLC Input: ", inp);
		var PDU_LLC dec := dec_PDU_LLC(inp);
		log("LLC Decoded: ", dec);
	}

	function f_llc_assert(in octetstring a, in octetstring b) {
		log("LLC Input: ", a);
		log("LLC Expected: ", b);

		if (a != b) {
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}


	testcase TC_selftest_llc() runs on dummy_CT {
		const octetstring c_gmm_att_pcu := '01c001080103e5e000210a0005f4fb146ddd32f44000c8001d1b53432b37159ef9090070000dd9c6321200e00019b32c642401c00020170580460b'O;
		const octetstring c_gmm_att_pcu_nofcs := '01c001080103e5e000210a0005f4fb146ddd32f44000c8001d1b53432b37159ef9090070000dd9c6321200e00019b32c642401c000201705'O;

		f_llc_dec_and_log(c_gmm_att_pcu);

		//f_llc_assert(f_LLC_append_fcs(c_gmm_att_pcu_nofcs), c_gmm_att_pcu);

		log(valueof(ts_LLC_UI(gmm_auth_req, c_LLC_SAPI_LLGMM, LLC_CR_DL_CMD, g_mmctx.n_u)));
		log(ts_LLC_UI(gmm_auth_req, c_LLC_SAPI_LLGMM, LLC_CR_DL_CMD, g_mmctx.n_u));
	}

	testcase TC_selftest_rlcmac() runs on dummy_CT {
		var RlcmacDlCtrlBlock dcb;
		var RlcmacUlCtrlBlock ucb;
		const octetstring c_dl_ul_ack_nack := '40240080400000000000000077628dbba14b2b2b2b2b2b'O;
		const octetstring c_dl_data := '0f00007341c001081200102198c72477ea104895e8b959acc58b108182f4d0454300'O;
		const octetstring c_dl_data2 := '070002165dc0012b2b2b43c0012b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b00'O;
		const octetstring c_ul_ctrl_ack := '4006ec51b7772b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b'O;
		const octetstring c_ul_dl_ack_nack := '4008004000000000000000701000edc0000b2b2b2b2b2b'O;
		const octetstring c_dl_ul_assign := '482857628dbbaf0126e68800082b2b2b2b2b2b2b2b2b2b'O;

		log(c_dl_ul_ack_nack);
		dcb := dec_RlcmacDlCtrlBlock(c_dl_ul_ack_nack);
		log(dcb);
		//log(dec_RlcmacDlCtrlMsg(dcb.payload));

		f_rlcmac_dld_decenc(c_dl_data);

		f_rlcmac_dld_decenc(c_dl_data2);

		log(c_ul_ctrl_ack);
		ucb := dec_RlcmacUlCtrlBlock(c_ul_ctrl_ack);
		log(ucb);
		//log(dec_RlcmacUlCtrlMsg(ucb.payload));

		log(c_ul_dl_ack_nack);
		ucb := dec_RlcmacUlCtrlBlock(c_ul_dl_ack_nack);
		log(ucb);
		//log(dec_RlcmacUlCtrlMsg(ucb.payload));

		log(c_dl_ul_assign);
		dcb := dec_RlcmacDlCtrlBlock(c_dl_ul_assign);
		log(dcb);
		//log(dec_RlcmacDlCtrlMsg(dcb.payload));

		const octetstring c_uld_tlli_noext := '080101a61cab5201c001080103e5e000310a0005f4e61cab5232f44000c8001d1b00'O;
		f_rlcmac_uld_decenc(c_uld_tlli_noext);

		const octetstring c_uld_tlli_ext7pad := '0001041da61cab5200201705a96e102b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b00'O;
		log("ULD_decenc");
		f_rlcmac_uld_decenc(c_uld_tlli_ext7pad);
		log("UL_decenc");
		f_rlcmac_ul_decenc(c_uld_tlli_ext7pad);

		f_rlcmac_ul_decenc(c_ul_dl_ack_nack);
	}

	function f_rlcmac_ul_decenc(in octetstring buf) {
		log("==================================");
		log("In: ", buf);
		var RlcmacUlBlock udb := dec_RlcmacUlBlock(buf);
		log("Dec: ", udb);
		var octetstring enc := enc_RlcmacUlBlock(udb);
		log("Enc: ", enc);
		if (enc != buf) { setverdict(fail, "Re-encoded data doesn't equal input data"); }
	}

	function f_rlcmac_uld_decenc(in octetstring buf) {
		log("==================================");
		log("In: ", buf);
		var RlcmacUlDataBlock udb := dec_RlcmacUlDataBlock(buf);
		log("Dec: ", udb);
		var octetstring enc := enc_RlcmacUlDataBlock(udb);
		log("Enc: ", enc);
		if (enc != buf) { setverdict(fail, "Re-encoded data doesn't equal input data"); }
	}

	function f_rlcmac_dld_decenc(in octetstring buf) {
		log("==================================");
		log("In: ", buf);
		var RlcmacDlDataBlock udb := dec_RlcmacDlDataBlock(buf);
		log("Dec: ", udb);
		var octetstring enc := enc_RlcmacDlDataBlock(udb);
		log("Enc: ", enc);
		if (enc != buf) { setverdict(fail, "Re-encoded data doesn't equal input data"); }
	}


	testcase TC_selftest_rr() runs on dummy_CT {
		//const octetstring c_paging_none := '06210001F02B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B'O
		const octetstring c_paging_none := '1506210001F0'O;
		const octetstring c_ia_tbf := '2d063f100fe3677bd8440000c800100b2b2b2b2b2b2b2b'O
		log(c_paging_none);
		log(dec_GsmRrMessage(c_paging_none));

		log(c_ia_tbf);
		log(dec_GsmRrMessage(c_ia_tbf));
	}

	control {
		execute(TC_selftest_bssgp());
		execute(TC_selftest_ns());
		execute(TC_selftest_llc());
		execute(TC_selftest_rr());
		execute(TC_selftest_rlcmac());
		execute(TC_nsem());
		execute(TC_paging());
	}
};
