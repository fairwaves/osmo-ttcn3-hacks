module Test {

	import from BSSGP_Helper_Functions all;
	import from BSSGP_Types all;
	import from BSSGP_Emulation all;
	import from NS_Types all;
	import from NS_Emulation all;

	type component dummy_CT {
		port BSSGP_PT BSSGP;
		var NS_CT ns_component;
		var BSSGP_CT bssgp_component;
	}

	function f_init() runs on dummy_CT {
		/* create a new NS component */
		ns_component := NS_CT.create;
		bssgp_component := BSSGP_CT.create;
		/* connect our BSSGP port to the BSSGP Emulation */
		connect(self:BSSGP, bssgp_component:BSSGP_SP);
		/* connect lower-end of BSSGP with BSSGP_CODEC_PORT (maps to NS_PT*/
		connect(bssgp_component:BSCP, ns_component:NS_SP);
		/* connect lower-end of NS emulation to NS_CODEC_PORT (on top of IPl4) */
		map(ns_component:NSCP, system:NS_CODEC_PORT);
		ns_component.start(NSStart());
		bssgp_component.start(BssgpStart());
	}

	function f_bssgp_assert_prepr(in octetstring a, in octetstring b) {
		log("BSSGP Input: ", a);
		log("BSSGP Expected: ", b);
		var octetstring a_preprocessed := f_BSSGP_expand_len(a);
		log("BSSGP Preprocessed: ", a_preprocessed);

		if (a_preprocessed != b) {
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	function f_bssgp_dec_and_log(in octetstring inp) {
		log("BSSGP Input: ", inp);
		var octetstring inp_p := f_BSSGP_expand_len(inp);
		log("BSSGP Preprocessed: ", inp_p);
		var BssgpPdu dec := dec_BssgpPdu(inp_p);
		log("BSSGP Decoded: ", dec);
	}

	testcase TC_selftest_bssgp() runs on dummy_CT {
		const octetstring c_bvc_reset_pcu := '2204820000078108088832f44000c80051e0'O;
		const octetstring c_bvc_reset_q := '2204820000078100'O;
		const octetstring c_status_pcu := '4107810515882204820000078103'O;
		const octetstring c_reset_ack_q := '2304820000'O;
		const octetstring c_reset_ack_pcu := '23048200c4'O;
		const octetstring c_unblock_pcu := '24048200c4'O;
		const octetstring c_unblock_ack_q := '25048200c4'O;
		const octetstring c_fc_bvc_pcu := '261e8101058200fa038200c8018200fa1c8200c806820000'O;
		const octetstring c_fc_bvc_ack_q := '271e8101'O;
		const octetstring c_gmm_mo_att_req := '01bb146ddd000004088832f44000c80051e000800e003b01c001080103e5e000110a0005f4fb146ddd32f44000c8001d1b53432b37159ef9090070000dd9c6321200e00019b32c642401c0002017057bf0ec'O;
		const octetstring c_gmm_mt_ac_req := '00bb146ddd0050001682ffff0a8204030e9c41c001081200102198c72477ea104895e8b959acc58b108182f4d045'O;
		const octetstring c_gmm_mo_ac_resp := '01bb146ddd000004088832f44000c80051e000800e000e01c00508130122fa361f5fdd623d'O;
		const octetstring c_gmm_mt_att_acc := '00bb146ddd0050001682ffff0a8204030e9841c005080201340432f44000c8001805f4fb146ddd0967d0'O;
		const octetstring c_gmm_mt_det_req := '00bb146ddd0050001682ffff0a8204030e8941c00908050215f0b6'O;
		const octetstring c_gmm_mo_att_cpl := '01fb146ddd000004088832f44000c80051e000800e000801c009080339d7bc'O;

		/* single byte length to two byte length */
		f_bssgp_assert_prepr('04058101'O, '0405000101'O);
		f_bssgp_assert_prepr('040589000102030405060708'O, '04050009000102030405060708'O);
		/* two byte length to two byte length */
		f_bssgp_assert_prepr('0405000101'O, '0405000101'O);
		/* special case: DL-UD + UL-UD */
		f_bssgp_assert_prepr('00aabbccddeeffaa29822342'O, '00aabbccddeeffaa2900022342'O);
		f_bssgp_assert_prepr('01aabbccddeeffaa29822342'O, '01aabbccddeeffaa2900022342'O);
		/* multiple TLVs */
		f_bssgp_assert_prepr('234281aa4382bbbb'O, '23420001aa430002bbbb'O);
		f_bssgp_assert_prepr('230080'O, '23000000'O);

		f_bssgp_dec_and_log(c_bvc_reset_pcu);
		f_bssgp_dec_and_log(c_bvc_reset_q);
		f_bssgp_dec_and_log(c_status_pcu);
		f_bssgp_dec_and_log(c_reset_ack_q);
		f_bssgp_dec_and_log(c_reset_ack_pcu);
		f_bssgp_dec_and_log(c_unblock_pcu);
		f_bssgp_dec_and_log(c_unblock_ack_q);
		f_bssgp_dec_and_log(c_fc_bvc_pcu);
		f_bssgp_dec_and_log(c_fc_bvc_ack_q);
		f_bssgp_dec_and_log(c_gmm_mo_att_req);
		f_bssgp_dec_and_log(c_gmm_mt_ac_req);
		f_bssgp_dec_and_log(c_gmm_mo_ac_resp);
		f_bssgp_dec_and_log(c_gmm_mt_att_acc);
		f_bssgp_dec_and_log(c_gmm_mt_det_req);
		f_bssgp_dec_and_log(c_gmm_mo_att_cpl);
	}

	function f_ns_assert_prepr(in octetstring a, in octetstring b) {
		log("NS Input: ", a);
		log("NS Expected: ", b);
		var octetstring a_preprocessed := f_NS_expand_len(a);
		log("NS Preprocessed: ", a_preprocessed);

		if (a_preprocessed != b) {
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	function f_ns_dec_and_log(in octetstring inp) {
		log("NS Input: ", inp);
		var octetstring inp_p := f_NS_expand_len(inp);
		log("NS Preprocessed: ", inp_p);
		var NsPdu dec := dec_NsPdu(inp_p);
		log("NS Decoded: ", dec);
	}

	testcase TC_selftest_ns() runs on dummy_CT {
		const octetstring c_ns_reset_pcu := '000000c4271e813d'O;

		/* single byte length to two byte length */
		f_ns_assert_prepr('04058101'O, '0405000101'O);
		f_ns_assert_prepr('040589000102030405060708'O, '04050009000102030405060708'O);
		/* two byte length to two byte length */
		f_ns_assert_prepr('0405000101'O, '0405000101'O);
		/* special case: NS-UNITDATA */
		f_ns_assert_prepr('00aabbccddeeffaa29822342'O, '00aabbccddeeffaa2900022342'O);
		/* multiple TLVs */
		f_ns_assert_prepr('234281aa4382bbbb'O, '23420001aa430002bbbb'O);
		/* zero-length */
		f_ns_assert_prepr('230080'O, '23000000'O);

		f_ns_dec_and_log(c_ns_reset_pcu);
	}

	testcase TC_nsem() runs on dummy_CT {
		timer T:= 60.0;

		f_init();
		T.start
		alt {
			[] BSSGP.receive(t_BssgpStsInd(?, ?, BVC_S_UNBLOCKED)) { }
			[] BSSGP.receive { repeat; }
			[] T.timeout { setverdict(fail); }
		}
		T.stop
		log("BSSGP successfully initialized");

		while (true) {
			var BssgpPdu pdu;
			alt {
				[] BSSGP.receive(BssgpPdu:?) -> value pdu {
					log("BSSGP Rx: ", pdu);
				}
				[] BSSGP.receive(t_BssgpStsInd(?, ?, BVC_S_UNBLOCKED)) { repeat; }
				[] BSSGP.receive { repeat; }
			}
		}
	}

	control {
		execute(TC_selftest_bssgp());
		execute(TC_selftest_ns());
		execute(TC_nsem());
	}
};
